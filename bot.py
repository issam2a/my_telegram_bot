import os
import requests
import bcrypt
import random
import logging
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Bot, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from database import init_db
from dotenv import load_dotenv
from telegram.error import BadRequest
import mysql.connector
import re
from fastapi import FastAPI, Request
import asyncio
import uvicorn



# Load environment variables
load_dotenv()

# Initialize the database
def connect_db():
    return mysql.connector.connect(
        host= DATABASE_HOST,
        user=DATABASE_USER,
        password=DATABASE_PASSWORD,
        database=DATABASE_NAME
    )

# Temporary storage for user account creation process
user_data = {}

# Secure credentials & API endpoints
AGENT_USERNAME = os.getenv("AGENT_USERNAME")
AGENT_PASSWORD = os.getenv("AGENT_PASSWORD")
PAYEER_ACCOUNT =os.getenv("PAYEER_ACCOUNT")
SYREATEL_ACCOUNT=os.getenv("SYREATEL_ACCOUNT")
BEMO_ACCOUNT=os.getenv("BEMO_ACCOUNT")
BOT_TOKEN = os.getenv("BOT_TOKEN")
DATABASE_PASSWORD= os.getenv("DATABASE_PASSWORD")
DATABASE_USER=os.getenv("DATABASE_USER")
DATABASE_NAME=os.getenv("DATABASE_NAME")
DATABASE_HOST=os.getenv("DATABASE_HOST")
LOGIN_URL = "https://agents.wayxbet.com/global/api/User/signIn"
REGISTER_USER_URL = "https://agents.wayxbet.com/global/api/Player/registerPlayer"
FIXED_PARENT_ID = "2301209"
FETCH_PLAYER_DETAILS="https://agents.wayxbet.com/global/api/Statistics/getPlayersStatisticsPro"
FETCH_PLAYER_BALANCE="https://agents.wayxbet.com/global/api/Player/getPlayerBalanceById"
DEPOSIT_URL = "https://agents.wayxbet.com/global/api/Player/depositToPlayer"
WITHDRAW_WEBSITE_URL = "https://agents.wayxbet.com/global/api/Player/withdrawFromPlayer"
exchange_rate = 10000
WEBHOOK_URL = "https://2bc4-169-150-196-153.ngrok-free.app/webhook" 



app = FastAPI()
telegram_app = ApplicationBuilder().token(BOT_TOKEN).build()

# ‚úÖ Set up logging for debugging
logging.basicConfig(level=logging.INFO) 

async def start_bot():
    """Initialize and start the Telegram bot."""
        
    await telegram_app.initialize()
    await telegram_app.start()
    print("‚úÖ Telegram bot initialized!")

@app.post("/webhook")
async def telegram_webhook(request: Request):
    """Receive updates from Telegram and process them."""
    try:
        update_data = await request.json()
        if not update_data:
            raise ValueError("Received empty JSON from Telegram")
        
        logging.info(f"üì© Received update: {update_data}")
        update = Update.de_json(update_data, telegram_app.bot)
        await telegram_app.process_update(update)

        return {"status": "ok"}

    except Exception as e:
        logging.error(f"‚ùå Error processing webhook: {e}")
        return {"status": "error", "message": str(e)}

async def set_webhook():
    """Set Telegram webhook to FastAPI server."""
    response = requests.post(
        f"https://api.telegram.org/bot{BOT_TOKEN}/setWebhook",
        json={"url": WEBHOOK_URL},
    )
    if response.status_code == 200:
        print("‚úÖ Webhook set successfully!")
    else:
        print(f"‚ùå Failed to set webhook: {response.text}")


@app.on_event("startup")
async def on_startup():
    """Run on FastAPI startup: Set webhook & start the bot."""
    await set_webhook()
    asyncio.create_task(start_bot())  # ‚úÖ Initialize the bot
    

logging.basicConfig(level=logging.DEBUG)  # ‚úÖ Enable debug logging
from fastapi import FastAPI, Request
import logging
import re
from datetime import datetime
import sys



@app.post("/sms")
async def receive_sms(request: Request):
    """Receive SMS from SMS Forwarder and process the transaction."""
    try:
        # ‚úÖ Get raw request body and headers
        raw_body = await request.body()
        headers = request.headers

        print(f"üì© Raw request body: {raw_body.decode('utf-8')}")
        print(f"üì© Headers: {headers}")  # ‚úÖ Check Content-Type
        
        # ‚úÖ Safely parse JSON
        try:
            sms_data = await request.json()
        except Exception as json_error:
            sys.stderr.write(f"‚ùå JSON Parsing Error: {json_error}\n")
            return {"status": "error", "message": "Invalid JSON format"}

        # ‚úÖ Extract SMS text and timestamp
        raw_text = sms_data.get("key", "").strip()
        raw_time = sms_data.get("time", "").strip()

        # ‚úÖ Convert time to `YYYY-MM-DD HH:MM:SS` format
        try:
            formatted_time = datetime.strptime(raw_time, "%d/%m, %I:%M %p").strftime("%Y-%m-%d %H:%M:%S")
        except ValueError:
            formatted_time = "Unknown"

        print(f"üì© Received SMS: {raw_text} at {formatted_time}")

        # ‚úÖ Process the cleaned SMS content
        result = await process_sms(raw_text, update=None, context=None)
        
        

        return {"status": "ok", "message": result}

    except Exception as e:
        sys.stderr.write(f"‚ùå Error processing SMS: {e}\n")  # ‚úÖ Force print errors
        logging.error(f"‚ùå Error processing SMS: {e}")
        return {"status": "error", "message": str(e)}

    



# Global session for agent authentication
agent_session = None

def generate_fake_email(username):
    """Generate a fake email based on the username."""
    return f"{username}{random.randint(1000, 9999)}@fakeemail.com"

def hash_password(password):
    """Securely hash passwords."""
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode(), salt).decode()


logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def login_as_agent():
    """Log in as an agent and store the session globally."""
    global agent_session
    session = requests.Session()
     # Set proxy (Replace with actual Syrian proxy)
   
    
    try:
        response = session.post(LOGIN_URL, json={"username": AGENT_USERNAME, "password": AGENT_PASSWORD}, headers={
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0",
            "Origin": "https://agents.wayxbet.com",
            "Referer": "https://agents.wayxbet.com"
        })

        response.raise_for_status()  # Raise an error for bad responses

        if response.status_code == 200 and response.json().get("result", {}).get("message") == "dashboard":
            logging.info("‚úÖ Agent login successful!")
            agent_session = session
            return True
        else:
            logging.error(f"‚ùå Agent login failed: {response.text}")

    except requests.exceptions.RequestException as e:
        logging.error(f"‚ùå Login request failed: {str(e)}")
    
    return False

def fetch_player_details(username):
    """Fetch player details using the search API after account creation."""
    global agent_session
    if not agent_session and not login_as_agent():
        return None

    payload = {
        "start": 0,
        "limit": 10,
        "filter": {},
        "searchBy": {"players": username}
    }

    response = agent_session.post(FETCH_PLAYER_DETAILS, json=payload)

    if response.status_code == 200:
        data = response.json()
        if data.get("status") and data["result"]["records"]:
            player_data = data["result"]["records"][0]  # Get the first matching record
            return {
                "playerId": player_data["playerId"],
                "username": player_data["username"]
            }

    return None 

def fetch_player_balance(user_id):
    """Fetch player balance using player_id and update the database."""
    global agent_session

    # Ensure the agent session is active
    if not agent_session and not login_as_agent():
        return {"error": "Failed to log in as agent"}

    conn = None
    cursor = None

    try:
        conn = connect_db()
        cursor = conn.cursor()

        # Fetch player_id from the database
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            return {"error": "User ID not found in accounts table"}

        player_id = result[0]  # Extract player_id

    except mysql.connector.Error as err:
        print(f"‚ùå MySQL Error: {err}")
        return {"error": "Database error occurred"}

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # API Call to Fetch Player Balance
    payload = {"playerId": str(player_id)}

    try:
        response = agent_session.post(FETCH_PLAYER_BALANCE, json=payload)
        response.raise_for_status()  # Raise an exception for HTTP errors
        data = response.json()  # Parse JSON response

        if data.get("status") and "result" in data:
            balance_info = data["result"]

            # Handle if balance_info is a list instead of a dictionary
            if isinstance(balance_info, list) and balance_info:
                balance_info = balance_info[0]  # Extract first item if it's a list

            website_balance = balance_info.get("balance", 0)
            currency = balance_info.get("currencyCode", "Unknown")

            # Update the database with the new website balance
            try:
                conn = connect_db()
                cursor = conn.cursor()
                cursor.execute("UPDATE wallets SET website_balance = %s WHERE user_id = %s", 
                               (website_balance, user_id))
                conn.commit()

            except mysql.connector.Error as err:
                print(f"‚ùå MySQL Error (Updating balance): {err}")

            finally:
                if cursor:
                    cursor.close()
                if conn:
                    conn.close()

            return {
                "balance": website_balance,
                "currency": currency
            }

        else:
            return {"error": "Invalid response structure or player not found"}

    except requests.exceptions.RequestException as e:
        return {"error": str(e)}



#------------------------------------create user on the website funcion ------------------------


def create_user_on_website(username, password):
    """Create a user account on the website and return account details."""
    global agent_session
    if not agent_session and not login_as_agent():
        return None
    
    payload = {
        "player": {
            "email": generate_fake_email(username),
            "password": password,
            "parentId": FIXED_PARENT_ID,
            "login": username
        }
    }
    response = agent_session.post(REGISTER_USER_URL, json=payload)
    
    if response.status_code == 200:
        data = response.json()
        if data.get("status"):  # Check if account creation was successful
            player_details = fetch_player_details(username)  # Fetch player details
            
            if player_details:
                return {
                    "username": player_details["username"],
                    "password": password,
                    "playerId": player_details["playerId"]
                    
                }

    return None  # Return None if creation or fetching fails


#--------------------------start command ------------------------------------------


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /start command and display terms for first-time users."""
    
    context.user_data["state"] = "expecting_no_input"
    user_id = update.message.from_user.id 

    user = update.effective_user  # Get the user object
    first_name = user.first_name  # Get the user's first name
    
    user_exists = None  # Initialize variable
    welcome_sticker_id = "CAACAgIAAxkBAeLeCmfdgKwm3XwP2yxX-l0gOsdn2xSbAAIxNAAC6BugStKvp8RmJqK8NgQ"  # Replace with your sticker ID
    try:
        conn = connect_db()
        cursor = conn.cursor()
        
        # Check if the user exists in the database
        cursor.execute("SELECT user_id FROM accounts WHERE user_id = %s", (user_id,))
        user_exists = cursor.fetchone()

    except mysql.connector.Error as err:
        print(f"‚ùå MySQL Error: {err}")
        await update.message.reply_text("‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇŸãÿß!")
        return  # Stop execution in case of an error

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    terms_text = ""
    if not user_exists:
        # If the user is new, send the Terms and Conditions first
        terms_text = (
            "üìú ÿ¥ÿ±Ÿàÿ∑ Ÿàÿ£ÿ≠ŸÉÿßŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™:\n\n"
            "üü• ÿ£ŸÜÿ™ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑ ÿßŸÑŸàÿ≠ŸäÿØ ÿπŸÜ ÿ£ŸÖŸàÿßŸÑŸÉÿå ÿØŸàÿ±ŸÜÿß ŸäŸÇÿ™ÿµÿ± ÿπŸÑŸâ ÿßŸÑŸàÿ≥ÿßÿ∑ÿ© ÿ®ŸäŸÜŸÉ Ÿàÿ®ŸäŸÜ ÿßŸÑŸÖŸàŸÇÿπÿå ŸÖÿπ ÿ∂ŸÖÿßŸÜ ÿ•ŸäÿØÿßÿπ Ÿàÿ≥ÿ≠ÿ® ÿ£ŸÖŸàÿßŸÑŸÉ ÿ®ŸÉŸÅÿßÿ°ÿ© ŸàŸÖŸàÿ´ŸàŸÇŸäÿ©.\n\n"
            "üü• ŸÑÿß Ÿäÿ¨Ÿàÿ≤ ŸÑŸÑÿßÿπÿ® ÿ•ŸäÿØÿßÿπ Ÿàÿ≥ÿ≠ÿ® ÿßŸÑÿ£ÿ±ÿµÿØÿ© ÿ®ŸáÿØŸÅ ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ®ŸäŸÜ Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿØŸÅÿπ. ÿ™ÿ≠ÿ™ŸÅÿ∏ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿßŸÑÿ≠ŸÇ ŸÅŸä ÿ≥ÿ≠ÿ® ÿ£Ÿä ÿ±ÿµŸäÿØ ŸàÿßŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®Ÿá ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿ™ÿ®ÿØŸäŸÑ ÿ£Ÿà ÿ£Ÿä ÿßŸÜÿ™ŸáÿßŸÉ ŸÑŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ®Ÿàÿ™.\n\n"
            "üü• ÿ•ŸÜÿ¥ÿßÿ° ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ≠ÿ≥ÿßÿ® Ÿäÿ§ÿØŸä ÿ•ŸÑŸâ ÿ≠ÿ∏ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ Ÿàÿ™ÿ¨ŸÖŸäÿØ ÿßŸÑÿ£ÿ±ÿµÿØÿ© ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸäŸáÿßÿå Ÿàÿ∞ŸÑŸÉ ŸàŸÅŸÇÿßŸã ŸÑÿ¥ÿ±Ÿàÿ∑ Ÿàÿ£ÿ≠ŸÉÿßŸÖ ÿßŸÑŸÖŸàŸÇÿπ ŸÑŸÑÿ≠ÿØ ŸÖŸÜ ÿßŸÑÿ£ŸÜÿ¥ÿ∑ÿ© ÿßŸÑÿßÿ≠ÿ™ŸäÿßŸÑŸäÿ©ÿå ŸàÿßŸÖÿ™ÿ´ÿßŸÑÿßŸã ŸÑÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑŸÑÿπÿ® ÿßŸÑŸÜÿ∏ŸäŸÅ.\n\n"
            "üìå ŸäŸèÿπÿØŸë ÿßŸÜÿ∂ŸÖÿßŸÖŸÉ ŸÑŸÑÿ®Ÿàÿ™ Ÿàÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÖŸàÿßŸÅŸÇÿ© ÿπŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑÿ¥ÿ±Ÿàÿ∑ÿå Ÿàÿ™ÿ≠ŸÖŸÑ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑŸäÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ© ÿπŸÜ ÿ£Ÿä ÿßŸÜÿ™ŸáÿßŸÉ ŸÑŸáÿß.\n\n"
        )

    # Define the main menu keyboard
    keyboard = [[
        InlineKeyboardButton("üÜï ÿßŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® Ÿàÿ™ÿπÿ®ÿ¶ÿ™Ÿá ", callback_data='create_account'),
        InlineKeyboardButton("üí≥ ŸÖÿ≠ŸÅÿ∑ÿ© ÿßŸÑÿ®Ÿàÿ™ Ÿàÿ¥ÿ≠ŸÜŸáÿß ", callback_data='charge')
    ], [
        InlineKeyboardButton("üí∏ ÿßŸÑÿ±ÿµŸäÿØ", callback_data='cash'),
        InlineKeyboardButton("üìä ÿπÿ±ÿ∂ ÿ¢ÿÆÿ± 5 ŸÖÿπÿßŸÖŸÑÿßÿ™", callback_data="show_transactions")
    ], 
    [InlineKeyboardButton("üé∞ Slot Machine", callback_data="slot_machine")],
    [
        InlineKeyboardButton("üìú ÿßŸÑÿ¥ÿ±Ÿàÿ∑ Ÿà ÿßŸÑÿ£ÿ≠ŸÉÿßŸÖ", callback_data='terms')
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    message = f"ŸÖÿ±ÿ≠ÿ®ÿßŸãüëã `{first_name}` ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿÆÿØŸÖÿ© ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©."
    await update.message.reply_sticker(sticker=welcome_sticker_id)

    # If the user is new, send terms first, then send the main menu
    if terms_text:
        await update.message.reply_text(terms_text, parse_mode="Markdown")

    # Send the main menu
    await update.message.reply_text(message, reply_markup=reply_markup, parse_mode="Markdown")

#--------------------------------Terms command --------------------------------------------

    
#--------------------------------help command ----------------------------------------------

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query

    keyboard = [
        [InlineKeyboardButton("üìñ ÿ≠ÿ≥ÿßÿ®Ÿä", callback_data='help_account')],
        [InlineKeyboardButton("üí∞ ÿßŸÑÿ•ŸäÿØÿßÿπ", callback_data='help_deposit')],
        [InlineKeyboardButton("üí∏ ÿßŸÑÿ≥ÿ≠ÿ®", callback_data='help_withdraw')],
        [InlineKeyboardButton("üìû ÿßŸÑÿØÿπŸÖ", callback_data='help_support')],
       
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    help_text = (
        "üÜò ŸÇÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©\n\n"
        "ÿßÿÆÿ™ÿ± ÿ£ÿ≠ÿØ ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ ÿßŸÑÿ™ÿßŸÑŸäÿ© ŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑŸÖÿ≤ŸäÿØ:\n"
        "üìñ ÿ≠ÿ≥ÿßÿ®Ÿä - ŸÉŸäŸÅŸäÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® Ÿàÿ•ÿØÿßÿ±ÿ™Ÿá.\n"
        "üí∞ ÿßŸÑÿ•ŸäÿØÿßÿπ - ŸÉŸäŸÅŸäÿ© ÿ¥ÿ≠ŸÜ ÿ≠ÿ≥ÿßÿ®ŸÉ.\n"
        "üí∏ ÿßŸÑÿ≥ÿ≠ÿ® - ŸÉŸäŸÅŸäÿ© ÿ≥ÿ≠ÿ® ÿßŸÑÿ£ŸÖŸàÿßŸÑ.\n"
        "üìû ÿßŸÑÿØÿπŸÖ - ŸÉŸäŸÅŸäÿ© ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß ŸÑÿ≠ŸÑ ŸÖÿ¥ÿßŸÉŸÑŸÉ."
    )

    await update.message.reply_text(help_text, reply_markup=reply_markup, parse_mode="Markdown")
    
    
    
#================================Button commands============================================

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle button clicks and navigation."""
    
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    # Initialize user navigation history if not exists
    if "history" not in context.user_data:
        context.user_data["history"] = []

#--------------------------------Create account Button commands--------------------------------------------
    if query.data == 'create_account':
        context.user_data["state"] = "expecting_Create_accout_input"

        try:
            conn = connect_db()
            cursor = conn.cursor()
            cursor.execute("SELECT username, player_id FROM accounts WHERE user_id = %s", (user_id,))
            account = cursor.fetchone()  # Fetch before closing cursor
            
            
             # Fetch bot balance from wallets
            cursor.execute("SELECT bot_balance FROM wallets WHERE user_id = %s", (user_id,))
            bot_result = cursor.fetchone()

            bot_balance = bot_result[0] if bot_result else 0  # Handle None case safely
            
            
        except mysql.connector.Error as err:
            print(f"‚ùå MySQL Error: {err}")
            await query.edit_message_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß.")
            return
        
        finally:
            cursor.close()
            conn.close()
            
           
         # Fetch website balance from API
         

         
         
            print("done")
        

        if account:
            username, player_id = account
            keyboard = [
                [InlineKeyboardButton("üåê WayXbet ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿßŸÑŸâ ŸÖŸàŸÇÿπ ", url="https://m.wayxbet.com/en/")],
                [InlineKeyboardButton("üí∞ ÿ¥ÿ≠ŸÜ ÿßŸÑÿ≠ÿ≥ÿßÿ®", callback_data='charge_website_account'), 
                 InlineKeyboardButton("üí∏ ÿ≥ÿ≠ÿ® ÿ±ÿµŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ®", callback_data='withdraw_website')],
                [InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            balance_details = fetch_player_balance(user_id)
            if "error" in balance_details:
                balance_text = f"‚ö†Ô∏è Error: {balance_details['error']}"
                
            else:
             balance_text = (
                f"üí∞ ÿßŸÑÿ±ÿµŸäÿØ:\n"
                f"üíµ ÿ±ÿµŸäÿØŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ: `{balance_details.get('balance', 0)}` {balance_details.get('currency', 'SYP')}\n"
                f"ü§ñ ÿ±ÿµŸäÿØ ÿßŸÑÿ®Ÿàÿ™: `{bot_balance}` {balance_details.get('currency', 'SYP')}\n"
            )
             
             
            
            message =( f"ÿ≠ÿ≥ÿßÿ® WayXbet ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ:\nüë§  ÿßÿ≥ŸÖ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ : {username}\n ‚öΩÔ∏è ŸÖÿπÿ±ŸÅ ÿßŸÑŸÑÿßÿπÿ®:  {player_id}\n"
                      f"{balance_text}")
            await query.edit_message_text(message, reply_markup=reply_markup)
            
        else:
            user_data[user_id] = {"step": "username"}  # Store state properly
            await query.edit_message_text("ÿ£ÿØÿÆŸÑ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ  ")

#--------------------------------üí≥ ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ®Ÿàÿ™ Ÿàÿ¥ÿ≠ŸÜŸáÿß Button commands--------------------------------------------
    elif query.data == 'charge':
        context.user_data["state"] = "expecting_no_input"

        try:
            conn = connect_db()
            cursor = conn.cursor()
            
            # Fetch user player_id
            cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
            player_data = cursor.fetchone()

            # Fetch bot balance
            cursor.execute("SELECT bot_balance FROM wallets WHERE user_id = %s", (user_id,))
            bot_result = cursor.fetchone()

            bot_balance = bot_result[0] if bot_result else 0  # Handle None case

        except mysql.connector.Error as err:
            print(f"‚ùå MySQL Error: {err}")
            await query.edit_message_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.")
            return

        finally:
            cursor.close()
            conn.close()

        if player_data:
            # Fetch website balance from external API
            balance_details = fetch_player_balance(user_id)

            if "error" in balance_details:
                balance_text = f"‚ö†Ô∏è Error: {balance_details['error']}"
            else:
                balance_text = (
                    f"üí∞ ÿßŸÑÿ±ÿµŸäÿØ:\n"
                    f"üíµ  ÿ±ÿµŸäÿØŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ :  `{balance_details.get('balance', 0)}` {balance_details.get('currency', 'SYP')}\n"
                    f"üíµü§ñ ÿ±ÿµŸäÿØ ÿßŸÑÿ®Ÿàÿ™ : `{bot_balance}` {balance_details.get('currency', 'SYP')}\n"
                )
        else:
            balance_text = "‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ®. Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ£ŸàŸÑÿß."
            erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"

         
            await update.message.reply_sticker(sticker=erorr_sticker_id)
            await query.edit_message_text(balance_text, parse_mode="Markdown")
            return

        keyboard = [
            [InlineKeyboardButton("üí∞ (ŸÅŸàÿ±Ÿä) ÿ¥ÿ≠ŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ®Ÿàÿ™", callback_data='charge_bot'),
             InlineKeyboardButton("üí∏ ÿ≥ÿ≠ÿ® ŸÖŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ®Ÿàÿ™", callback_data="withdraw_from_bot")],
            
            [InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        context.user_data["history"].append((balance_text, keyboard))

        await query.edit_message_text(balance_text, reply_markup=reply_markup, parse_mode="Markdown")

#-------------------------game functions -------------------------------------------------------------------------------


    elif query.data == 'slot_machine':
        # ‚úÖ Connect to the database
        conn = connect_db()
        cursor = conn.cursor()
        cursor.execute("select player_id from accounts where user_id = %s" ,(user_id,))
        player_id = cursor.fetchone()
        if player_id:
        
            await start_slot_machine(update, context)
        else:
            await query.edit_message_text("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ®. Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ£ŸàŸÑÿß.")
            return
        conn.close()

    
    
    elif query.data == 'charge_bot':
        context.user_data["state"] = "expecting_no_input"
        keyboard = [
            [InlineKeyboardButton("üè¶  ÿ®ŸäŸÖŸà", callback_data='charge_bemo')],
            [InlineKeyboardButton("üí≥  ÿ®ÿßŸäŸäÿ±", callback_data='charge_payeer')],
            [InlineKeyboardButton("üì±  ÿ≥Ÿäÿ±Ÿäÿßÿ™ŸÑ ŸÉÿßÿ¥", callback_data='charge_syriatel')],
            [InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Save the current menu before changing
        context.user_data["history"].append(("üí∞ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ:", keyboard))
        

        await query.edit_message_text("üí∞ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ:", reply_markup=reply_markup, parse_mode="Markdown")
        
        
#--------------------------------charge payeer Button commands--------------------------------------------

        
    elif query.data == 'charge_payeer':
     context.user_data["state"] = "expecting_payeer_transaction_id"
    
    # Send the payment instructions
     payeer_wallet = PAYEER_ACCOUNT
     
     image_path = "imges/payeeer_instructions.jpg"

     payment_text = (
        f"üí∞ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ•ŸÑŸâ ÿ≠ÿ≥ÿßÿ® Payeer ÿßŸÑÿ™ÿßŸÑŸä:\n\n"
        f"üè¶ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ®Ÿàÿ™: `{payeer_wallet}`\n\n"
        f"üíµ ÿ≥ÿπÿ± ÿßŸÑÿµÿ±ŸÅ:  Payeer 1 USD = {exchange_rate} ÿ®ÿßŸÑÿπŸÖŸÑÿ© ÿßŸÑŸÖÿ≠ŸÑŸäÿ©\n\n"
        f"üìå ÿ®ÿπÿØ ÿßŸÑÿØŸÅÿπÿå ŸÇŸÖ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑŸÖŸÉŸàŸÜ ŸÖŸÜ 10 ÿ£ÿ±ŸÇÿßŸÖ\n"
        f"üìç (ŸÖÿ´ÿßŸÑ: `210573xxxx`)\n\n"
        f"‚ö†Ô∏è ŸÑÿß ÿ™ŸÇÿ®ŸÑ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ¥ÿ≠ŸÜ ÿ®ÿØŸàŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© (Operation ID)!"
     )

     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
     reply_markup = InlineKeyboardMarkup(keyboard)

     with open(image_path, "rb") as photo:
        await context.bot.send_photo(
            chat_id=query.message.chat_id,
            photo=photo,
            caption=payment_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
     print("User is now expected to send transaction ID")  # Debugging



#--------------------------------charge syriatel Button commands--------------------------------------------
        
    elif query.data == "charge_syriatel":
        context.user_data["state"] = "expecting_syriatel_transaction_id"
        syriatel_cash_code = SYREATEL_ACCOUNT
        image_path = "imges/syreatel_cash_charge_instructions.jpg"  # Ensure this image exists in your bot's directory
        payment_text = (
        "üì≤ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ•ŸÑŸâ ŸÉŸàÿØ ÿßŸÑÿ™ÿßÿ¨ÿ± ÿßŸÑÿ™ÿßŸÑŸä Ÿàÿ®ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸäÿØŸàŸä ÿ≠ÿµÿ±ÿßŸã ŸÉŸÖÿß ŸÖŸàÿ∂ÿ≠ ÿ®ÿßŸÑÿµŸàÿ±ÿ© üëÜ:\n\n"
        f"üè¶ ŸÉŸàÿØ Syriatel Cash ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑÿ®Ÿàÿ™: `{syriatel_cash_code}`\n\n"
        "üìå ÿ®ÿπÿØ ÿØŸÅÿπ ÿßŸÑŸÖÿ®ŸÑÿ∫ÿå ŸÇŸÖ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑŸÖŸÉŸàŸÜ ŸÖŸÜ:\n"
        "üîπ  12ÿ±ŸÇŸÖ ,(ŸÖÿ´ÿßŸÑ: `600000xxxxxx`)\n"
        "üîπ ÿ£Ÿà 15 ÿ±ŸÇŸÖ (ŸÖÿ´ÿßŸÑ: `80000000xxxxxxx`)\n\n"
        "‚ö†Ô∏è ŸÑÿß ÿ™ŸÇÿ®ŸÑ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ¥ÿ≠ŸÜ ŸÖŸÜ ÿØŸàŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©!"
    )

        keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Send the image and message together
        with open(image_path, "rb") as photo:
         await context.bot.send_photo(
            chat_id=query.message.chat_id,
            photo=photo,
            caption=payment_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        context.user_data["history"].append((photo, keyboard))
        
        
        

#--------------------------------charge Beom Button commands--------------------------------------------


    elif query.data == "charge_bemo":
     context.user_data["state"] = "expecting_bemo_transaction_id"
     bemo_account = BEMO_ACCOUNT
     image_path = "imges/bemo_instructions.jpg"  # Ensure this image exists in your bot's directory
    
     payment_text = (
        "üì≤ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿ±ÿßÿØ ÿ¥ÿ≠ŸÜŸá ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ™ÿßŸÑŸä:\n\n"
        f"üè¶ ÿ±ŸÇŸÖ ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ®ŸäŸÖŸà ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑÿ®Ÿàÿ™: `{bemo_account}`\n\n"
        "üìå Ÿàÿ®ÿπÿØ ÿØŸÅÿπ ÿßŸÑŸÖÿ®ŸÑÿ∫ ...\n"
        "üîπ ŸÇŸÖ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑŸÖŸÉŸàŸÜ ŸÖŸÜ 9 ÿ£ÿ±ŸÇÿßŸÖ\n"
        "üîπ ŸÉŸÖÿß ŸÖŸàÿ∂ÿ≠ ŸÅŸä ÿßŸÑÿ£ÿπŸÑŸâ üëÜ\n\n"
        "üîπ (ŸÖÿ´ÿßŸÑ: 25951xxxx)\n\n"
        "‚ö†Ô∏è ŸÑÿß ÿ™ŸÇÿ®ŸÑ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ¥ÿ≠ŸÜ ŸÖŸÜ ÿØŸàŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©!"
     )

     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
     reply_markup = InlineKeyboardMarkup(keyboard) 

    # Send the image and message together
     with open(image_path, "rb") as photo:
        await context.bot.send_photo(
            chat_id=query.message.chat_id,
            photo=photo,
            caption=payment_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
    
    # Save history for back navigation
     context.user_data["history"].append((payment_text, keyboard))
     

   
   
   #--------------------------------ÿßŸÑÿ±ÿµŸäÿØ Button commands--------------------------------------------
   
    elif query.data == 'cash':
        context.user_data["state"] = "expecting_no_input"

        try:
         conn = connect_db()
         cursor = conn.cursor()

         # Fetch player_id from accounts
         cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
         player_data = cursor.fetchone()

         # Fetch bot balance from wallets
         cursor.execute("SELECT bot_balance FROM wallets WHERE user_id = %s", (user_id,))
         bot_result = cursor.fetchone()

         bot_balance = bot_result[0] if bot_result else 0  # Handle None case safely

        except mysql.connector.Error as err:
         print(f"‚ùå MySQL Error: {err}")
         await query.edit_message_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.")
         return  # Exit to prevent further execution

        finally:
         cursor.close()
         conn.close()

        if player_data:
         # Fetch website balance from API
         balance_details = fetch_player_balance(user_id)

         if "error" in balance_details:
            balance_text = f"‚ö†Ô∏è Error: {balance_details['error']}"
         else:
            balance_text = (
                f"üí∞ ÿßŸÑÿ±ÿµŸäÿØ:\n"
                f"üíµ ÿ±ÿµŸäÿØŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ: `{balance_details.get('balance', 0)}` {balance_details.get('currency', 'SYP')}\n"
                f"ü§ñ ÿ±ÿµŸäÿØ ÿßŸÑÿ®Ÿàÿ™: `{bot_balance}` {balance_details.get('currency', 'SYP')}\n"
            )
            print("done")
        else:
         balance_text = "‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ®. Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ£ŸàŸÑÿß."

        keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(balance_text, reply_markup=reply_markup, parse_mode="Markdown")
         

        
#--------------------------------üí∏ ÿ≥ÿ≠ÿ® ŸÖŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ®Ÿàÿ™" Button commands--------------------------------------------

    elif query.data == 'withdraw_from_bot':
        context.user_data["state"] = "expecting_no_input"
        keyboard = [
            [InlineKeyboardButton("üè¶ ÿ®ŸäŸÖŸà", callback_data='withdrawl_bemo')],
            [InlineKeyboardButton("üí≥ ÿ®ÿßŸäŸäÿ±", callback_data='withdrawl_payeer')],
            [InlineKeyboardButton("üì± ÿ≥Ÿäÿ±Ÿäÿßÿ™ŸÑ ŸÉÿßÿ¥", callback_data='withdrawl_syriatel')],
            [InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Save the current menu before changing
        context.user_data["history"].append(("üí∞ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ≥ÿ≠ÿ®:", keyboard))
        

        await query.edit_message_text("üí∞ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ≥ÿ≠ÿ®:", reply_markup=reply_markup, parse_mode="Markdown")
        
        
    elif query.data.startswith("withdrawl_"):
     method = query.data.split("_")[1]  # Extracts 'bemo', 'payeer', or 'syriatel'
     # Store method and set state
     context.user_data["withdraw_method"] = method
     context.user_data["state"] = "expecting_withdraw_amount"
     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
     reply_markup = InlineKeyboardMarkup(keyboard) 
     if method == "payeer":
         await query.edit_message_text(
        f"üí∞ ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫  ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ≥ÿ≠ÿ®Ÿá ÿ®ÿπŸÖŸÑÿ© USD  ÿπÿ®ÿ± {method.upper()}:"
        ,
        reply_markup=reply_markup, parse_mode="Markdown"
    )
        
      
     else:
         
      await query.edit_message_text(
        f"üí∞ ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ≥ÿ≠ÿ®Ÿá ÿπÿ®ÿ± {method.upper()}:",
        reply_markup=reply_markup, parse_mode="Markdown"
    )    
     



#-------------------------------- üí∞ ÿ¥ÿ≠ŸÜ ÿßŸÑÿ≠ÿ≥ÿßÿ®" Button commands--------------------------------------------

    elif query.data == 'charge_website_account':
        context.user_data["state"] = "expecting_website_charge_amount_From_Bot"

        await query.message.reply_text(
        "üí∞ ÿßŸÑÿ≠ÿØ ÿßŸÑÿßÿØŸÜŸâ ŸÑŸÑÿ™ÿπÿ®ÿ¶ÿ© ŸáŸà 10.000 ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ™ÿ≠ŸàŸäŸÑŸá ÿ•ŸÑŸâ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ:",
        parse_mode="Markdown"
    )
        

#-------------------------------- üí∞ ÿ≥ÿ≠ÿ® ÿ±ÿµŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ®" Button commands--------------------------------------------

    elif query.data == 'withdraw_website':
     context.user_data["state"] = "expecting_website_withdraw_amount_To_Bot"
     
     await query.message.reply_text("üíµ ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿ±ÿßÿØ ÿ≥ÿ≠ÿ®Ÿá ŸÖŸÜ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ:", parse_mode="Markdown")
    
#--------------------------------ÿ±ÿ¨Ÿàÿπ  Button commands--------------------------------------------


    elif query.data == 'back':
     context.user_data["state"] = "expecting_no_input"
     if context.user_data.get("history") and len(context.user_data["history"]) > 1:
        # Get the previous menu before popping the current one
        previous_menu_text, previous_keyboard = context.user_data["history"][-2]

        # Now safely remove the current menu from history
        context.user_data["history"].pop()
        
        

        reply_markup = InlineKeyboardMarkup(previous_keyboard)

        try:
            if query.message.text:
                # If it's a text message, edit it normally
                await query.edit_message_text(previous_menu_text, reply_markup=reply_markup, parse_mode='Markdown')
            else:
                # If the last message was a photo, delete it and send a new message
                await query.message.delete()
                await context.bot.send_message(
                    chat_id=query.message.chat_id,
                    text=previous_menu_text,
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
        except BadRequest as e:
            if "Message is not modified" in str(e):
                pass  # Ignore the error
            else:
                raise  # Re-raise other errors

     else:
        # If no history, go back to the main menu
        main_text = "ŸÖÿ±ÿ≠ÿ®ÿßŸãüòá ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿÆÿØŸÖÿ© ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©."
        main_markup = InlineKeyboardMarkup(main_menu_keyboard())

        if query.message.text != main_text:
            try:
                await query.edit_message_text(main_text, reply_markup=main_markup, parse_mode='Markdown')
            except BadRequest as e:
                if "Message is not modified" in str(e):
                    pass  # Ignore the error
                else:
                    raise  # Re-raise other errors

#-------------------------------------help button -------------------------------------------------

    elif query.data == "help":
     context.user_data["state"] = "expecting_no_input"
     keyboard = [
        [InlineKeyboardButton("üìñ ÿ≠ÿ≥ÿßÿ®Ÿä", callback_data='help_account')],
        [InlineKeyboardButton("üí∞ ÿßŸÑÿ•ŸäÿØÿßÿπ", callback_data='help_deposit')],
        [InlineKeyboardButton("üí∏ ÿßŸÑÿ≥ÿ≠ÿ®", callback_data='help_withdraw')],
        [InlineKeyboardButton("üìû ÿßŸÑÿØÿπŸÖ", callback_data='help_support')],
     ]
     reply_markup = InlineKeyboardMarkup(keyboard)

     help_text = (
        "üÜò ŸÇÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© \n\n"
        "üîπ ÿßÿÆÿ™ÿ± ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿßŸÑŸÑŸä ÿ®ÿØŸÉ ÿ™ÿπÿ±ŸÅ ÿπŸÜŸá ÿ£ŸÉÿ™ÿ±:\n\n"
        "üìñ ÿ≠ÿ≥ÿßÿ®Ÿä - ÿ∑ÿ±ŸäŸÇÿ© ÿ•ŸÜÿ¥ÿßÿ° Ÿàÿ•ÿØÿßÿ±ÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ.\n"
        "üí∞ ÿßŸÑÿ•ŸäÿØÿßÿπ - ŸÉŸäŸÅ ÿ™ÿ¥ÿ≠ŸÜ ÿ±ÿµŸäÿØŸÉ ÿ®ÿ≥ŸáŸàŸÑÿ©.\n"
        "üí∏ ÿßŸÑÿ≥ÿ≠ÿ® - ÿ∑ÿ±ŸäŸÇÿ© ÿ≥ÿ≠ÿ® ÿ£ÿ±ÿ®ÿßÿ≠ŸÉ.\n"
        "üìû ÿßŸÑÿØÿπŸÖ - ŸÉŸäŸÅ ÿ™ÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß ŸÑÿ≠ŸÑ ÿ£Ÿä ŸÖÿ¥ŸÉŸÑÿ©."
     )

     context.user_data["history"].append((help_text, keyboard))
     await query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode="Markdown")
     
     #---------------------------------help acount ----------------------------------------------
    elif query.data == "help_account":
     context.user_data["state"] = "expecting_no_input"
     help_text = (
         
         #TODO  add an instruction vedio 
        "üëÜ ÿßŸÉÿ®ÿ≥ ÿ≤ÿ± Start Ÿàÿ®ÿπÿØŸáÿß ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® Ÿàÿ™ÿπÿ®ÿ¶ÿ™Ÿá Ÿàÿ™ÿßÿ®ÿπ ŸÖÿπ ÿßŸÑÿ®Ÿàÿ™... ü§ñüí¨\n\n"
        "üìù ÿßŸÑÿ®Ÿàÿ™ ÿ±ÿ≠ Ÿäÿ∑ŸÑÿ® ŸÖŸÜŸÉ ÿ™ÿÆÿ™ÿßÿ± ÿßÿ≥ŸÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸàŸÉŸÑŸÖÿ© ÿ≥ÿ± üîí ŸÑÿ≠ÿ≥ÿßÿ®ŸÉÿå ÿßÿÆÿ™ÿßÿ± ÿßŸÑŸÑŸä ÿ®ŸÜÿßÿ≥ÿ®ŸÉÿå Ÿàÿ®ÿπÿØŸáÿß ÿ±ÿ≠ ŸäŸÇŸÑŸÉ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úîÔ∏èüéâ\n\n"
        "üîë ÿ®ÿπÿØ ŸÖÿß ÿ™ŸÜÿ¥ÿ¶ ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿå ŸÅŸàÿ™ ÿπÿßŸÑŸÖŸàŸÇÿπ Ÿàÿ≥ÿ¨ŸÑ ÿØÿÆŸàŸÑ ŸÖÿ™ŸÑ ŸÖŸà ŸÖŸàÿ∂ÿ≠ ÿ®ÿßŸÑŸÅŸäÿØŸäŸà üìπ.\n\n"
        "üì© ÿ¥ŸàŸÅ ÿßŸÑŸÅŸäÿØŸäŸà Ÿàÿ¨ÿ±ÿ®ÿå Ÿàÿ•ÿ∞ÿß Ÿàÿßÿ¨Ÿáÿ™ŸÉ ÿ£Ÿä ŸÖÿ¥ŸÉŸÑÿ©ÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß ÿπ ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿØÿπŸÖ üìûüëç."
     )
     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='help')]]
     reply_markup = InlineKeyboardMarkup(keyboard)
     context.user_data["history"].append((help_text, keyboard))
     await query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode="Markdown")
    
#-----------------------------------------help deposit-------------------------------------------

             #TODO  add an instruction vedio 

    elif query.data == "help_deposit":
     context.user_data["state"] = "expecting_no_input"
     help_text = (
        "üí∞ ÿßŸÑÿ•ŸäÿØÿßÿπ\n\n"
    "üîπ ŸÅŸäŸÉ ÿ™ÿ¥ÿ≠ŸÜ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ÿ£ŸÉÿ™ÿ± ŸÖŸÜ ÿ∑ÿ±ŸäŸÇÿ©ÿå ŸÖÿ´ŸÑ Payeer, Bemo Bank, Syriatel Cash.\n"
    "üîπ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ Ÿàÿ≠ŸàŸëŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ŸÑŸÑÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ÿØÿØ.\n"
    "üîπ ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑÿå ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÑŸäÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿØŸÅÿπ."
     )
     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='help')]]
     reply_markup = InlineKeyboardMarkup(keyboard)
     context.user_data["history"].append((help_text, keyboard))
     await query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode="Markdown")



#-------------------------------------help_withdraw-----------------------------------------------
         #TODO  add an instruction vedio 

    elif query.data == "help_withdraw":
     context.user_data["state"] = "expecting_no_input"
     help_text = (
        "üí∏ ÿßŸÑÿ≥ÿ≠ÿ®\n\n"
        "üîπ ŸÅŸäŸÉ ÿ™ÿ≥ÿ≠ÿ® ŸÖÿµÿßÿ±Ÿä ŸÑÿ≠ÿ≥ÿßÿ® ÿ®ŸäŸÖŸà ÿå Payeerÿå ÿ£Ÿà Syriatel Cash.\n"
        
        f"üí∞ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿπŸÑŸâ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ≥ÿ≠ÿ®: \n"
        
        f"üîπ 5Ÿ™ - ÿπŸÑŸâ ŸÉŸÑ ÿπŸÖŸÑŸäÿ© ÿ≥ÿ≠ÿ®\n\n"
        f"üîπ ŸÇÿØŸÖ ÿ∑ŸÑÿ® ÿßŸÑÿ≥ÿ≠ÿ® Ÿàÿ≠ŸÜÿπÿßŸÑÿ¨Ÿá ÿÆŸÑÿßŸÑ 24 ÿ≥ÿßÿπÿ©."
     )
     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='help')]]
     reply_markup = InlineKeyboardMarkup(keyboard)
     context.user_data["history"].append((help_text, keyboard))
     await query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode="Markdown")


#--------------------------------------help_support------------------------------------------------


    elif query.data == "help_support":
     context.user_data["state"] = "expecting_no_input"
     help_text = (
        "üìû ÿßŸÑÿØÿπŸÖ\n\n"
        "üîπ ÿ•ÿ∞ÿß Ÿàÿßÿ¨Ÿáÿ™ ÿ£Ÿä ŸÖÿ¥ŸÉŸÑÿ©ÿå  ÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß ÿπÿ®ÿ±:\n"
        
        "‚òéÔ∏è ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ: -0991 685 557\n"
        
     )
     keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='help')]]
     reply_markup = InlineKeyboardMarkup(keyboard)
     context.user_data["history"].append((help_text, keyboard))
     await query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode="Markdown")


    
#--------------------------------terms button ----------------------------------------------------------
    elif query.data == "terms":
     context.user_data["state"] = "expecting_no_input"
     terms_text = (
        "üìú ÿ¥ÿ±Ÿàÿ∑ Ÿàÿ£ÿ≠ŸÉÿßŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™:\n\n"
        "üü• ÿ£ŸÜÿ™ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑ ÿßŸÑŸàÿ≠ŸäÿØ ÿπŸÜ ÿ£ŸÖŸàÿßŸÑŸÉÿå ÿØŸàÿ±ŸÜÿß ŸäŸÇÿ™ÿµÿ± ÿπŸÑŸâ ÿßŸÑŸàÿ≥ÿßÿ∑ÿ© ÿ®ŸäŸÜŸÉ Ÿàÿ®ŸäŸÜ ÿßŸÑŸÖŸàŸÇÿπÿå ŸÖÿπ ÿ∂ŸÖÿßŸÜ ÿ•ŸäÿØÿßÿπ Ÿàÿ≥ÿ≠ÿ® ÿ£ŸÖŸàÿßŸÑŸÉ ÿ®ŸÉŸÅÿßÿ°ÿ© ŸàŸÖŸàÿ´ŸàŸÇŸäÿ©.\n\n"
        "üü• ŸÑÿß Ÿäÿ¨Ÿàÿ≤ ŸÑŸÑÿßÿπÿ® ÿ•ŸäÿØÿßÿπ Ÿàÿ≥ÿ≠ÿ® ÿßŸÑÿ£ÿ±ÿµÿØÿ© ÿ®ŸáÿØŸÅ ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ®ŸäŸÜ Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿØŸÅÿπ. ÿ™ÿ≠ÿ™ŸÅÿ∏ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿßŸÑÿ≠ŸÇ ŸÅŸä ÿ≥ÿ≠ÿ® ÿ£Ÿä ÿ±ÿµŸäÿØ ŸàÿßŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®Ÿá ÿ•ÿ∞ÿß ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿ™ÿ®ÿØŸäŸÑ ÿ£Ÿà ÿ£Ÿä ÿßŸÜÿ™ŸáÿßŸÉ ŸÑŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ®Ÿàÿ™.\n\n"
        "üü• ÿ•ŸÜÿ¥ÿßÿ° ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ≠ÿ≥ÿßÿ® Ÿäÿ§ÿØŸä ÿ•ŸÑŸâ ÿ≠ÿ∏ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ Ÿàÿ™ÿ¨ŸÖŸäÿØ ÿßŸÑÿ£ÿ±ÿµÿØÿ© ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸäŸáÿßÿå Ÿàÿ∞ŸÑŸÉ ŸàŸÅŸÇÿßŸã ŸÑÿ¥ÿ±Ÿàÿ∑ Ÿàÿ£ÿ≠ŸÉÿßŸÖ ÿßŸÑŸÖŸàŸÇÿπ ŸÑŸÑÿ≠ÿØ ŸÖŸÜ ÿßŸÑÿ£ŸÜÿ¥ÿ∑ÿ© ÿßŸÑÿßÿ≠ÿ™ŸäÿßŸÑŸäÿ©ÿå ŸàÿßŸÖÿ™ÿ´ÿßŸÑÿßŸã ŸÑÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑŸÑÿπÿ® ÿßŸÑŸÜÿ∏ŸäŸÅ.\n\n"
        
        "üìå ŸäŸèÿπÿØŸë ÿßŸÜÿ∂ŸÖÿßŸÖŸÉ ŸÑŸÑÿ®Ÿàÿ™ Ÿàÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÖŸàÿßŸÅŸÇÿ© ÿπŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑÿ¥ÿ±Ÿàÿ∑ÿå Ÿàÿ™ÿ≠ŸÖŸÑ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑŸäÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ© ÿπŸÜ ÿ£Ÿä ÿßŸÜÿ™ŸáÿßŸÉ ŸÑŸáÿß.\n\n"
       
     )
     
     await query.edit_message_text(terms_text)
     
    elif query.data == "show_transactions":
        await handle_show_last_transactions(update, context)

#--------------------------------confirm_withdraw_button-----------------------------------------------
    elif query.data.startswith("confirm_withdraw"):
        data = query.data.replace("confirm_withdraw_", "", 1)  # Remove prefix
        amount, method = data.rsplit("_", 1)  
        amount = int(amount)  # Convert amount to integer
        context.user_data["withdraw_amount"] = amount
        context.user_data["state"] = "expecting_payment_account"

        await query.message.reply_text(
         f"üè¶ Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿßŸÑÿÆÿßÿµ ÿ®ŸÄ {method.upper()}:",
         parse_mode="Markdown"
          )

    elif query.data == "cancel_withdraw":
        await query.edit_message_text("‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≥ÿ≠ÿ®.")

                
        


def main_menu_keyboard():
    """Returns the main menu keyboard."""
    return [[
        InlineKeyboardButton("üÜï ÿßŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® Ÿàÿ™ÿπÿ®ÿ¶ÿ™Ÿá ", callback_data='create_account'),
        InlineKeyboardButton("üí≥ ŸÖÿ≠ŸÅÿ∑ÿ© ÿßŸÑÿ®Ÿàÿ™ Ÿàÿ¥ÿ≠ŸÜŸáÿß ", callback_data='charge')
    ], [
        InlineKeyboardButton("üí∏ ÿßŸÑÿ±ÿµŸäÿØ", callback_data='cash'),
        InlineKeyboardButton("üìä ÿπÿ±ÿ∂ ÿ¢ÿÆÿ± 5 ŸÖÿπÿßŸÖŸÑÿßÿ™", callback_data="show_transactions")
    ],
    [InlineKeyboardButton("üé∞ Slot Machine", callback_data="slot_machine")],
    [
        InlineKeyboardButton("üìú ÿßŸÑÿ¥ÿ±Ÿàÿ∑ Ÿà ÿßŸÑÿ£ÿ≠ŸÉÿßŸÖ", callback_data='terms')
        
    ]]
    

    
    

#--------------------------------user inout handlers--------------------------------------------
  
async def handle_user_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user input based on their state."""
    
    user_id = update.message.from_user.id  # Get Telegram user ID
    user_input = update.message.text.strip()
    
    state = context.user_data.get("state", None)
    erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"

    if state == "expecting_Create_accout_input":
        await handel_create_account(update, context, user_input)

    elif state == "expecting_syriatel_transaction_id":
        await handle_charge_syriatel_transaction_id(update, context, user_input)

    elif state == "expecting_payeer_transaction_id":
        await handle_charge_payeer_transaction_id(update, context, user_input)

    elif state == "expecting_bemo_transaction_id":
        await handle_charge_bemo_transaction_id(update, context, user_input)

    elif state == "expecting_website_charge_amount_From_Bot":
        await handle_website_charge_amount_From_Bot(update, context, user_input)

    elif state == "expecting_website_withdraw_amount_To_Bot":
        await handle_website_withdraw_amount_To_Bot(update, context, user_input)
        
    elif state == "awaiting_deposit_amount":
        await handle_deposit_amount(update, context)

    elif state == "expecting_withdraw_amount":
        method = context.user_data.get("withdraw_method")  # Get selected method

        if not method:
            await update.message.reply_text("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ≥ÿ≠ÿ®!", parse_mode="Markdown")
            return
        
        # ‚úÖ Call `process_withdrawal_amount_from_bot_to_user` Instead of Handling It Here
        await process_withdrawal_amount_from_bot_to_user(update, context, user_input, method)

    elif state == "expecting_payment_account":
        account_number = user_input.strip()

        if len(account_number) < 5:  # Validate input
            await update.message.reply_sticker(sticker=erorr_sticker_id)
            await update.message.reply_text("‚ùå ÿ±ŸÇŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠! ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠.", parse_mode="Markdown")
            return

        # Store the account number
        context.user_data["account_number"] = account_number

        # ‚úÖ Call the final withdrawal processing function
        await finalize_withdrawal(update, context)
        
    elif state == "expecting_deposit_charge_amount":
        await handle_deposit_amount(update, context, user_input)
        
    
    
    else:
        await update.message.reply_sticker(sticker=erorr_sticker_id)
        await update.message.reply_text("‚ö†Ô∏è ÿ•ÿØÿÆÿßŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ! Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ÿÆŸäÿßÿ± ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©.", parse_mode="Markdown")

        
        
        

#--------------------------------account createion handler --------------------------------------------
  

async def handel_create_account(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str):
    """Handles user account creation in MySQL database"""

    # ‚úÖ Detect whether the update is a message or callback query
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text
    else:
        return  # Prevent crashes if neither exists

    text = update.message.text.strip()

    # ‚úÖ Step 1: Check if the user is at the username input stage
    if user_id in user_data and user_data[user_id]["step"] == "username":
        try:
            conn = connect_db()
            cursor = conn.cursor()

            # ‚úÖ Check if username exists in MySQL
            cursor.execute("SELECT username FROM accounts WHERE username = %s", (text,))
            existing_user = cursor.fetchone()

            if existing_user:
                await send_message("‚ùå ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ. ÿßÿÆÿ™ÿ± ÿßÿ≥ŸÖŸãÿß ŸÖÿÆÿ™ŸÑŸÅŸãÿß.")
            else:
                user_data[user_id] = {"step": "password", "username": text}
                await send_message("üîë ÿ£ÿØÿÆŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿÆÿßÿµÿ© ÿ®ŸÉ.")
            
        except mysql.connector.Error as err:
            print(f"‚ùå MySQL Error: {err}")
            await send_message("‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.")
        
        finally:
            cursor.close()
            conn.close()

    # ‚úÖ Step 2: Handle password input and insert into MySQL
    elif user_id in user_data and user_data[user_id]["step"] == "password":
        username = user_data[user_id]["username"]
        password = text
        hashed_password = hash_password(password)  # Hash password for security

        try:
            conn = connect_db()
            cursor = conn.cursor()

            # ‚úÖ Create account on external website (if needed)
            account_details = create_user_on_website(username, password)

            if account_details:
                player_id = account_details.get("playerId")

                # ‚úÖ Insert user data into MySQL
                cursor.execute(
                    "INSERT INTO accounts (player_id, username, password, user_id) VALUES (%s, %s, %s, %s)", 
                    (player_id, username, hashed_password, user_id)
                )

                # ‚úÖ Insert default wallet balance for the new user
                cursor.execute(
                    "INSERT INTO wallets (user_id) VALUES (%s)", 
                    (user_id,)
                )

                conn.commit()  # ‚úÖ Commit the transaction

                await send_message(
                    f"‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ®ŸÜÿ¨ÿßÿ≠!\n"
                    f"üë§ Username: `{username}`\n"
                    f"üîë Password: `{password}`\n"
                    f"üÜî Player ID: `{player_id}`\n\n"
                    "‚ö†Ô∏è ŸäŸèÿ±ÿ¨Ÿâ ÿ™ÿ∫ŸäŸäÿ± ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿ≠ÿ≥ÿßÿ®ŸÉ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿßŸÑŸÖŸàŸÇÿπ ŸÑÿ≠ŸÖÿßŸäÿ™Ÿá!"
                )

                # ‚úÖ Reset user state after successful registration
                context.user_data["state"] = None
                user_data.pop(user_id, None)  # Remove user from temporary state tracking
            
            else:
                await send_message("‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®.")

        except mysql.connector.Error as err:
            print(f"‚ùå MySQL Error: {err}")
            await send_message("‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇŸãÿß.")

        finally:
            cursor.close()
            conn.close()

        
        
#================================payment functions===============================================



#--------------------------------Syriatel cash payment function--------------------------------------------

async def handle_charge_syriatel_transaction_id(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str ):
   
    """Handles the Syriatel Cash transaction ID input from the user."""
    print("‚úÖ Bot is expecting a syreatel cash transaction ID, processing...")  # Debugging
    
    # ‚úÖ Detect whether the update is a message or callback query
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text  # ‚úÖ Use update.message
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text  # ‚úÖ Use update.callback_query.message
    else:
        return  # Prevent crashes if neither exists
    
    processing_sticker_id = "CAACAgIAAxkBAeLe02fdg4hbX96ODk5SRx08-jtV08apAALDPQACzBMpSoUPzZoaigNGNgQ"
    erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"
    warning_sticker_id ="CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
    success_sticker_id="CAACAgIAAxkBAeLfjWfdhmXMrgLfaZJoEAWhTenCC6DrAALnNQACtoxBS2JmFwWrYLwGNgQ"
    syriatel_cash_transaction_id = update.message.text.strip()
    
    if context.user_data.get("state") != "expecting_syriatel_transaction_id":
        await update.message.reply_sticker(sticker=warning_sticker_id)
        await send_message("‚ö†Ô∏è ÿ•ÿØÿÆÿßŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ! ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ ÿ£ŸàŸÑÿßŸã.")
        return

    # Validate transaction ID format (12 or 15 digits)
    if not (syriatel_cash_transaction_id.isdigit() and len(syriatel_cash_transaction_id) in [12, 15]):
        await send_message(
            "‚ùå ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠!\n\n"
            "üîπ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÖŸÉŸàŸÜÿßŸã ŸÖŸÜ 12 ÿ±ŸÇŸÖŸãÿß (ŸÖÿ´ÿßŸÑ: `600000xxxxxx`)\n"
            "üîπ ÿ£Ÿà 15 ÿ±ŸÇŸÖŸãÿß (ŸÖÿ´ÿßŸÑ: `80000000xxxxxxx`)\n\n"
            "üîÑ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ Ÿàÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠!",
            parse_mode="Markdown"
        )
        return

     # ‚úÖ Connect to the database
    conn = connect_db()
    cursor = conn.cursor()

    try:
        
        # ‚úÖ Check if the transaction ID already exists
        cursor.execute("SELECT status FROM transactions WHERE external_transaction_id = %s", (syriatel_cash_transaction_id,))
        existing_transaction = cursor.fetchone()

        if existing_transaction:
          transaction_status = existing_transaction[0]  # Extract the status

          if transaction_status == "pending":
            await update.message.reply_sticker(sticker=processing_sticker_id)
            await send_message("‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÇŸäÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©..\n\n"
                           "‚è≥ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ≠ÿ™Ÿâ ÿßŸÉÿ™ŸÖÿßŸÑŸáÿß ü´°", 
                           parse_mode="Markdown")
          else:
            await update.message.reply_sticker(sticker=erorr_sticker_id)
            await send_message("‚ùå ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑÿ∞Ÿä ÿ£ÿØÿÆŸÑÿ™Ÿá ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ!\n\n"
                           "üîπ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ¨ÿØÿØŸãÿß.", 
                           parse_mode="Markdown")
          return  # Stop further execution
        
        # ‚úÖ Fetch player ID from accounts table
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            await send_message("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ®ŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ£ŸàŸÑÿßŸã.", parse_mode="Markdown")
            return

        player_id = result[0]  # Extract player_id safely

        # ‚úÖ Insert transaction into database
        cursor.execute(
            "INSERT INTO transactions (external_transaction_id, user_id, player_id, transaction_type, payment_method, status) "
            "VALUES (%s, %s, %s, 'deposit', 'Syriatel', 'pending')",
            (syriatel_cash_transaction_id, user_id, player_id)
        )

        conn.commit()  # ‚úÖ Save changes

         # ‚úÖ Store transaction ID in user context
        context.user_data["pending_transaction_id"] = syriatel_cash_transaction_id
        context.user_data["state"] = "awaiting_deposit_amount"
        
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message(
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\n"
            f"üíµ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©: `{syriatel_cash_transaction_id}`\n"
            
            ,parse_mode="Markdown"
        )
        
        await send_message(f"üî¢ ŸáŸÑÿ£ ÿØÿÆŸëŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÑŸä ÿ≠ŸàŸÑÿ™Ÿá ÿ®ÿßŸÑŸÑŸäÿ±ÿ© ÿßŸÑÿ≥Ÿàÿ±Ÿäÿ©. üí∞",parse_mode="Markdown")
        
        
    except Exception as e:
        print(f"‚ùå Database Error: {e}")  # Log error
        await send_message("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã.", parse_mode="Markdown")

    finally:
        cursor.close()
        conn.close()  # ‚úÖ Always close the database connection

    
    
# ------>> here call the function that check if the transaction is validated(def check_syreatel_cash_transaction_validation) 
# ------>> then the function update the user's bot_balance with the amount extracted form the sms 
   
 #--------------------------------payeer payment function----------------------------------------------------------



async def handle_charge_payeer_transaction_id(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str):
    """Handle user input when they send a Payeer transaction ID."""
    

    # ‚úÖ Detect whether the update is a message or callback query
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text  # ‚úÖ Use update.message
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text  # ‚úÖ Use update.callback_query.message
    else:
        return  # Prevent crashes if neither exists

    charge_payeer_transaction_id = update.message.text.strip()
    processing_sticker_id = "CAACAgIAAxkBAeLe02fdg4hbX96ODk5SRx08-jtV08apAALDPQACzBMpSoUPzZoaigNGNgQ"
    erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"
    warning_sticker_id ="CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
    success_sticker_id="CAACAgIAAxkBAeLfjWfdhmXMrgLfaZJoEAWhTenCC6DrAALnNQACtoxBS2JmFwWrYLwGNgQ"
    print("üì© Received message:", charge_payeer_transaction_id)  # Debugging

    # Ensure bot is expecting a transaction ID
    if context.user_data.get("state") != "expecting_payeer_transaction_id":
        await update.message.reply_sticker(sticker=warning_sticker_id)
        await send_message("‚ö†Ô∏è ÿ•ÿØÿÆÿßŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ! ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ ÿ£ŸàŸÑÿßŸã.")
        return
    
    print("‚úÖ Bot is expecting a transaction ID, processing...")  # Debugging

    # Validate the transaction ID (must be 10 digits)
    if not charge_payeer_transaction_id.isdigit() or len(charge_payeer_transaction_id) != 10:
        await update.message.reply_sticker(sticker=erorr_sticker_id)
        await send_message("‚ö†Ô∏è ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠! Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 10 ÿ£ÿ±ŸÇÿßŸÖÿå ŸÖÿ´ÿßŸÑ: 210573xxxx")
        return
    

     # ‚úÖ Connect to the database
    conn = connect_db()
    cursor = conn.cursor()

    try:
        
        # ‚úÖ Check if the transaction ID already exists
        cursor.execute("SELECT status FROM transactions WHERE external_transaction_id = %s", (charge_payeer_transaction_id,))
        existing_transaction = cursor.fetchone()

        if existing_transaction:
          transaction_status = existing_transaction[0]  # Extract the status

          if transaction_status == "pending":
            await update.message.reply_sticker(sticker=processing_sticker_id)
            await send_message("‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÇŸäÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©..\n\n"
                           "‚è≥ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ≠ÿ™Ÿâ ÿßŸÉÿ™ŸÖÿßŸÑŸáÿß ü´°", 
                           parse_mode="Markdown")
          else:
            await update.message.reply_sticker(sticker=erorr_sticker_id)
            await send_message("‚ùå ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑÿ∞Ÿä ÿ£ÿØÿÆŸÑÿ™Ÿá ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ!\n\n"
                           "üîπ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ¨ÿØÿØŸãÿß.", 
                           parse_mode="Markdown")
          return  # Stop further execution
        
        # ‚úÖ Fetch player ID from accounts table
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            await send_message("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ®ŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ£ŸàŸÑÿßŸã.", parse_mode="Markdown")
            return

        player_id = result[0]  # Extract player_id safely

        # ‚úÖ Insert transaction into database
        cursor.execute(
            "INSERT INTO transactions (external_transaction_id, user_id, player_id, transaction_type, payment_method, status) "
            "VALUES (%s, %s, %s, 'deposit', 'Payeer', 'pending')",
            (charge_payeer_transaction_id, user_id, player_id)
        )

        conn.commit()  # ‚úÖ Save changes

         # ‚úÖ Store transaction ID in user context
        context.user_data["pending_transaction_id"] = charge_payeer_transaction_id
        context.user_data["method"] = "Payeer"
        context.user_data["state"] = "awaiting_deposit_amount"
        
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message(
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\n"
            f"üíµ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©: `{charge_payeer_transaction_id}`\n"
            
            ,parse_mode="Markdown"
        )
        
        await send_message(f"üî¢ ÿßŸáŸÑÿ£ ÿØÿÆŸëŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÑŸä ÿ≠ŸàŸÑÿ™Ÿá  USD  üí∞",parse_mode="Markdown")

    except Exception as e:
        print(f"‚ùå Database Error: {e}")  # Log error
        await update.message.reply_sticker(sticker=erorr_sticker_id)
        await send_message("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã.", parse_mode="Markdown")

    finally:
        cursor.close()
        conn.close()  # ‚úÖ Always close the database connection

    
    

    # Acknowledge the user
    

# ------>> here call the function that check if the transaction is validated(def check_payeer_transaction_validation) 
# ------>> then the function (def check_payeer_transaction_validation) update the user's bot_balance with the amount extracted form payeer API call 
    
#--------------------------------Bemo payment function--------------------------------------------

    
async def handle_charge_bemo_transaction_id(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str):
    """Handles the Bemo Cash transaction ID input from the user and stores it in the database."""

    print("‚úÖ Bot is expecting a Bemo transaction ID, processing...")  # Debugging

    # ‚úÖ Detect message source
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text
    else:
        return  # Prevent crashes if neither exists

    bemo_transaction_id = update.message.text.strip()
    processing_sticker_id = "CAACAgIAAxkBAeLe02fdg4hbX96ODk5SRx08-jtV08apAALDPQACzBMpSoUPzZoaigNGNgQ"
    erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"
    warning_sticker_id ="CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
    success_sticker_id="CAACAgIAAxkBAeLfjWfdhmXMrgLfaZJoEAWhTenCC6DrAALnNQACtoxBS2JmFwWrYLwGNgQ"
    
    # Ensure bot is expecting a transaction ID
    if context.user_data.get("state") != "expecting_bemo_transaction_id":
        await update.message.reply_sticker(sticker=warning_sticker_id)
        await send_message("‚ö†Ô∏è ÿ•ÿØÿÆÿßŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ! ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ ÿ£ŸàŸÑÿßŸã.")
        return

    # ‚úÖ Validate transaction ID format (must be 9 digits)
    if not (bemo_transaction_id.isdigit() and len(bemo_transaction_id) == 9):
        await update.message.reply_sticker(sticker=erorr_sticker_id)
        await send_message(
            "‚ùå ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠!\n\n"
            "üîπ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÖŸÉŸàŸÜÿßŸã ŸÖŸÜ 9 ÿ£ÿ±ŸÇÿßŸÖ (ŸÖÿ´ÿßŸÑ: `600000123`)\n\n"
            "üîÑ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ Ÿàÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠!",
            parse_mode="Markdown"
        )
        return

    

    # ‚úÖ Connect to the database
    conn = connect_db()
    cursor = conn.cursor()

    try:
        
        # ‚úÖ Check if the transaction ID already exists and get its status
        cursor.execute("SELECT status FROM transactions WHERE external_transaction_id = %s", (bemo_transaction_id,))
        existing_transaction = cursor.fetchone()

        if existing_transaction:
          transaction_status = existing_transaction[0]  # Extract the status

          if transaction_status == "pending":
            await update.message.reply_sticker(sticker=processing_sticker_id)
            await send_message("‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÇŸäÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©..\n\n"
                           "‚è≥ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ≠ÿ™Ÿâ ÿßŸÉÿ™ŸÖÿßŸÑŸáÿß ü´°", 
                           parse_mode="Markdown")
          else:
            await update.message.reply_sticker(sticker=erorr_sticker_id)
            await send_message("‚ùå ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑÿ∞Ÿä ÿ£ÿØÿÆŸÑÿ™Ÿá ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ!\n\n"
                           "üîπ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ¨ÿØÿØŸãÿß.", 
                           parse_mode="Markdown")
          return  # Stop further execution

        
        
        # ‚úÖ Fetch player ID from accounts table
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            await update.message.reply_sticker(sticker=erorr_sticker_id)
            await send_message("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ®ŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ£ŸàŸÑÿßŸã.", parse_mode="Markdown")
            return

        player_id = result[0]  # Extract player_id safely

        # ‚úÖ Insert transaction into database
        cursor.execute(
            "INSERT INTO transactions (external_transaction_id, user_id, player_id, transaction_type, payment_method, status) "
            "VALUES (%s, %s, %s, 'deposit', 'Bemo', 'pending')",
            (bemo_transaction_id, user_id, player_id)
        )

        conn.commit()  # ‚úÖ Save changes

         # ‚úÖ Store transaction ID in user context
        context.user_data["pending_transaction_id"] = bemo_transaction_id
        context.user_data["state"] = "awaiting_deposit_amount"
        
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message(
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\n"
            f"üíµ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©: `{bemo_transaction_id}`\n"
            
            ,parse_mode="Markdown"
        )
        
        await send_message(f"üî¢ ŸáŸÑÿ£ ÿØÿÆŸëŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÑŸä ÿ≠ŸàŸÑÿ™Ÿá ÿ®ÿßŸÑŸÑŸäÿ±ÿ© ÿßŸÑÿ≥Ÿàÿ±Ÿäÿ©. üí∞",parse_mode="Markdown")

    except Exception as e:
        print(f"‚ùå Database Error: {e}")  # Log error
        await send_message("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã.", parse_mode="Markdown")

    finally:
        cursor.close()
        conn.close()  # ‚úÖ Always close the database connection

    
    
    

   
 
 
 
async def handle_deposit_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user input for deposit amount and updates the transaction record."""
    
    # ‚úÖ Detect message source
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text
    else:
        return  

    deposit_amount_text = update.message.text.strip()
    processing_sticker_id = "CAACAgIAAxkBAeLfTGfdhXlPLdyMr_PA2nAxtCwOq8CwAAISNQACx6ehSqkeK7OWc836NgQ"
    aproved_sticker_id = "CAACAgIAAxkBAeLfjWfdhmXMrgLfaZJoEAWhTenCC6DrAALnNQACtoxBS2JmFwWrYLwGNgQ"

    # ‚úÖ Ensure user is in the correct state
    if context.user_data.get("state") != "awaiting_deposit_amount":
        return 
    # ‚úÖ Validate deposit amount
    if not deposit_amount_text.replace(".", "", 1).isdigit():  # Allow decimals
        await send_message("‚ùå ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠!\n\n"
                           "üîπ Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ŸäŸÖÿ´ŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ (ŸÖÿ´ŸÑ: 10000 ÿ£Ÿà 150.5)",
                           parse_mode="Markdown")
        return

    deposit_amount = float(deposit_amount_text)

    if deposit_amount <= 0:
        await send_message("‚ùå Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ 0!", parse_mode="Markdown")
        return

    # ‚úÖ Retrieve pending transaction ID
    transaction_id = context.user_data.get("pending_transaction_id")
    method = context.user_data.get("method")

    if not transaction_id:
        await send_message("‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ÿ∑ŸÑÿ® ÿ•ŸäÿØÿßÿπ ŸÖÿπŸÑŸÇ ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ŸÉ! ÿ£ÿπÿØ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©.", parse_mode="Markdown")
        return

    # ‚úÖ Update transaction with amount
    conn = connect_db()
    cursor = conn.cursor()

    try:
        if method == "Payeer":
            deposit_amount = exchange_rate
            cursor.execute("""
            UPDATE transactions 
            SET amount = %s
            WHERE external_transaction_id = %s AND user_id = %s
        """, (deposit_amount, transaction_id, user_id))

            conn.commit()
            await update.message.reply_sticker(sticker=processing_sticker_id)
            await send_message(
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ®ŸÜÿ¨ÿßÿ≠!\n\n"
            f"üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫: `{deposit_amount}` SYP\n"
            f"‚è≥ ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑŸÖŸàÿßŸÅŸÇÿ© ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®...",
            parse_mode="Markdown"
            )
            
            
        else:
         cursor.execute("""
            UPDATE transactions 
            SET amount = %s
            WHERE external_transaction_id = %s AND user_id = %s
         """, (deposit_amount, transaction_id, user_id))

         conn.commit()
         
         await update.message.reply_sticker(sticker=processing_sticker_id)   
         await send_message(
            f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ®ŸÜÿ¨ÿßÿ≠!\n\n"
            f"üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫: `{deposit_amount}` SYP\n"
            f"‚è≥ ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑŸÖŸàÿßŸÅŸÇÿ© ÿπŸÑŸâ ÿßŸÑÿ∑ŸÑÿ®...",
            parse_mode="Markdown"
         )

    except Exception as e:
        print(f"‚ùå Database Error: {e}")  
        await send_message("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇŸãÿß!", parse_mode="Markdown")

    finally:
        cursor.close()
        conn.close()

    # ‚úÖ Reset user state
    context.user_data["state"] = None
    context.user_data.pop("pending_transaction_id", None)
    result = verify_transaction_from_user_input(transaction_id,user_id)
    if "error" in result:
     await send_message(result["error"])
     
    else:
     keyboard = [
                [InlineKeyboardButton("üåê WayXbet ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿßŸÑŸâ ŸÖŸàŸÇÿπ ", url="https://m.wayxbet.com/en/")],
                [InlineKeyboardButton("üí∞ ÿ¥ÿ≠ŸÜ ÿßŸÑÿ≠ÿ≥ÿßÿ®", callback_data='charge_website_account'), 
                 InlineKeyboardButton("üí∏ ÿ≥ÿ≠ÿ® ÿ±ÿµŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ®", callback_data='withdraw_website')],
                [InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]
            ]
     reply_markup = InlineKeyboardMarkup(keyboard)
     await update.message.reply_sticker(sticker=aproved_sticker_id)
     await send_message(f" ‚úÖ ÿ™ŸÖ ÿ™ÿπÿ®ÿ¶ÿ© ŸÖÿ≠ŸÅÿ∑ÿ© ÿßŸÑÿ®Ÿàÿ™ \n"
                        f"Good Luck üî•üí´"
                        ,reply_markup=reply_markup, parse_mode="Markdown")

#This function is triggered when an SMS is received via forwarding.


async def process_sms(sms_text, update: Update = None, context: ContextTypes.DEFAULT_TYPE = None):
    """Extract transaction details from SMS and verify against pending transactions."""
    bot = Bot(token= BOT_TOKEN)
    print("üì© Processing new SMS...")

    # ‚úÖ Detect message source (Reply in Bot Chat)
    user_id = None  # Default if triggered by an SMS
    send_message = None

    if update and context:
        if update.message:
            user_id = update.message.from_user.id
            send_message = update.message.reply_text
        elif update.callback_query:
            user_id = update.callback_query.from_user.id
            send_message = update.callback_query.message.reply_text

    # ‚úÖ Step 1: Remove "From: ..." if it exists
    sms_text = re.sub(r"^From : .+\n", "", sms_text)
    print(f"üîç Cleaned SMS Text: {sms_text}")

    # ‚úÖ Step 2: Check both patterns (Bemo & Syriatel Cash)
    pattern_bemo = r"ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ≠ŸàÿßŸÑÿ© ÿßŸÑŸÉÿ™ÿ±ŸàŸÜŸäÿ© (\d+)ŸÑ.ÿ≥ ŸÖŸÜ (.+?)ÿåÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© (\d{9})"
    pattern_syriatel = r"ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ŸÖÿ®ŸÑÿ∫ (\d+) ŸÑ.ÿ≥ ÿ®ŸÜÿ¨ÿßÿ≠. ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸáŸà (\d{12})"

    match_bemo = re.search(pattern_bemo, sms_text)
    match_syriatel = re.search(pattern_syriatel, sms_text)

    if match_bemo:
        print("‚úÖ Matched Pattern: Bemo Bank")
        sms_amount = float(match_bemo.group(1))
        sender_name = match_bemo.group(2)
        sms_transaction_id = match_bemo.group(3)
    elif match_syriatel:
        print("‚úÖ Matched Pattern: Syriatel Cash")
        sms_amount = float(match_syriatel.group(1))
        sender_name = "Syriatel Cash"
        sms_transaction_id = match_syriatel.group(2)
    else:
        print("‚ùå SMS format does not match expected patterns")
        if send_message:
            await send_message("‚ùå ÿ±ÿ≥ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàÿßŸÅŸÇÿ© ŸÖÿπ ÿßŸÑŸÜŸÖÿ∑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.", parse_mode="Markdown")
        return {"error": "‚ùå ÿ±ÿ≥ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàÿßŸÅŸÇÿ© ŸÖÿπ ÿßŸÑŸÜŸÖÿ∑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®"}

    print(f"‚úÖ Extracted Data: Transaction ID={sms_transaction_id}, Amount={sms_amount}, Sender={sender_name}")

    # ‚úÖ Step 3: Connect to MySQL
    try:
        conn = connect_db()
        cursor = conn.cursor()
        print("‚úÖ Database connection established.")

        # ‚úÖ Step 4: Check if the transaction exists in `transactions`
        cursor.execute("SELECT user_id, amount, status FROM transactions WHERE external_transaction_id = %s", (sms_transaction_id,))
        transaction = cursor.fetchone()

        if transaction:
            db_user_id, db_amount, status = transaction
            print(f"‚úÖ Transaction found: User ID={db_user_id}, Status={status}")

            # ‚úÖ Step 5: Verify transaction status
            if status != "pending":
                print("‚ö†Ô∏è Transaction is already verified or completed.")
                if db_user_id:
                    await bot.send_message(
                        chat_id=db_user_id,
                        text=
                        f"‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ™ŸÖÿ™ ŸÖÿπÿßŸÑÿ¨ÿ™Ÿáÿß ÿ®ÿßŸÑŸÅÿπŸÑÿå ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ∂ÿßŸÅÿ™Ÿáÿß ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.", parse_mode="Markdown")
                return {"error": "‚ö†Ô∏è Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ™ŸÖÿ™ ŸÖÿπÿßŸÑÿ¨ÿ™Ÿáÿß ÿ®ÿßŸÑŸÅÿπŸÑ."}

            # ‚úÖ Step 6: Verify transaction amount
            if db_amount != sms_amount:
                print("‚ùå Transaction amount does not match!")
                if db_user_id:
                    await bot.send_message(
                        chat_id=db_user_id,
                        text=
                        f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÖÿ®ŸÑÿ∫!.. ÿ™ÿßŸÉÿØ ŸÖŸÜ ÿßŸÑŸÖÿ®ŸÑÿ∫ Ÿàÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿßÿÆÿ±Ÿâ", parse_mode="Markdown")
                    cursor.execute("DELETE FROM transactions where external_transaction_id =%s",(sms_transaction_id,))
                    cursor.execute("INSERT INTO sms_logs (transaction_id, amount, sender_phone) VALUES (%s, %s, %s)", 
                        (sms_transaction_id, sms_amount, sender_name))

                    conn.commit()
                return {"error": "‚ùå ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ŸÖÿ∑ÿßÿ®ŸÇ!"}

            # ‚úÖ Step 7: Approve transaction and update user balance
            cursor.execute("""
                UPDATE transactions 
                SET status = 'approved', verification_source = 'SMS' 
                WHERE external_transaction_id = %s
            """, (sms_transaction_id,))

            cursor.execute("UPDATE wallets SET bot_balance = bot_balance + %s WHERE user_id = %s", (sms_amount, db_user_id))
            conn.commit()

            print(f"‚úÖ Transaction {sms_transaction_id} verified and balance updated!")

            # ‚úÖ Notify user inside the bot chat
            keyboard = [
                [InlineKeyboardButton("üåê WayXbet ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿßŸÑŸâ ŸÖŸàŸÇÿπ ", url="https://m.wayxbet.com/en/")],
                [InlineKeyboardButton("üí∞ ÿ¥ÿ≠ŸÜ ÿßŸÑÿ≠ÿ≥ÿßÿ®", callback_data='charge_website_account'), 
                InlineKeyboardButton("üí∏ ÿ≥ÿ≠ÿ® ÿ±ÿµŸäÿØ ÿßŸÑÿ≠ÿ≥ÿßÿ®", callback_data='withdraw_website')],
                [InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]
                ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if db_user_id:
             await bot.send_message(
             chat_id=db_user_id,
             text=f"‚úÖ ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿπŸÖŸÑŸäÿ™ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠!\n\nüí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫: `{sms_amount}` ŸÑ.ÿ≥\nüìå ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©: `{sms_transaction_id}`",
             parse_mode="Markdown",
             reply_markup=reply_markup  # ‚úÖ Include the inline keyboard
             )

            # ‚úÖ Reset user state
            if context:
                context.user_data["state"] = None

            return {"success": f"‚úÖ ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿπŸÖŸÑŸäÿ© Ÿàÿ•ÿ∂ÿßŸÅÿ© {sms_amount} ŸÑ.ÿ≥ ÿ•ŸÑŸâ ÿ±ÿµŸäÿØŸÉ!"}

        else:
            print(f"‚ö†Ô∏è Transaction {sms_transaction_id} not found, saving to `sms_logs`...")
            cursor.execute("INSERT INTO sms_logs (transaction_id, amount, sender_phone) VALUES (%s, %s, %s)", 
                        (sms_transaction_id, sms_amount, sender_name))
            conn.commit()

            return {"info": "‚ö†Ô∏è ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©ÿå ÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿáÿß ŸÑŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ŸÑÿßÿ≠ŸÇŸãÿß."}

    except Exception as e:
        print(f"‚ùå Database Error: {e}")
        return {"error": f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ: {str(e)}"}

    finally:
        cursor.close()
        conn.close()
        print("‚úÖ Database connection closed.")





def verify_transaction_from_user_input(transaction_id, user_id):
    """Verify a transaction when the user enters the transaction ID manually."""
    
    conn = connect_db()
    cursor = conn.cursor()
    
    
    
    # ‚úÖ Check if transaction already exists in `transactions`
    cursor.execute("SELECT amount, status FROM transactions WHERE external_transaction_id = %s AND user_id = %s", 
                   (transaction_id, user_id))
    transaction = cursor.fetchone()

    if transaction:
        amount, status = transaction

        if status != "pending":
            conn.close()
            return {"error": "Transaction is already verified or completed"}

        # ‚úÖ Check if SMS has already been received
        cursor.execute("SELECT amount FROM sms_logs WHERE transaction_id = %s", (transaction_id,))
        sms_entry = cursor.fetchone()

        if sms_entry:
            sms_amount = sms_entry[0]

            if sms_amount != amount:
                cursor.execute("DELETE FROM transactions WHERE external_transaction_id = %s",(transaction_id,))
                conn.commit()  # ‚úÖ Commit the deletion
                conn.close()
                return {"error": "ÿßŸÑŸÖÿ®ŸÑÿ∫ ŸÅŸä ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÜÿµŸäÿ© ŸÑÿß Ÿäÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖŸèÿØÿÆŸÑ ŸÑŸÑŸÖÿπÿßŸÖŸÑÿ© ‚ùå‚ö†Ô∏è Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ üîÑ‚úÖ"}

            # ‚úÖ Approve the transaction & credit balance
            cursor.execute("""
                UPDATE transactions 
                SET status = 'approved', verification_source = 'SMS' 
                WHERE external_transaction_id = %s
            """, (transaction_id,))
            
            cursor.execute("UPDATE wallets SET bot_balance = bot_balance + %s WHERE user_id = %s", (amount, user_id))

            # ‚úÖ Delete from `sms_logs` since it's now verified
            cursor.execute("DELETE FROM sms_logs WHERE transaction_id = %s", (transaction_id,))
            conn.commit()
            conn.close()

            return {"success": True, "message": f"Transaction {transaction_id} verified via SMS logs and balance updated!"}

        else:
            conn.close()
            return {
                        "error": "üîÑ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÇŸäÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©... ŸäŸèÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ≠ÿ™Ÿâ ÿßŸÉÿ™ŸÖÿßŸÑŸáÿß.\n"
                         "‚è≥ ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉÿ™ŸÖŸÑ ÿÆŸÑÿßŸÑ 10 ÿØŸÇÿßÿ¶ŸÇÿå ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.\n"
                         "‚ùå ŸÇÿØ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠.\n"
                         "üìû ŸÅŸä ÿ≠ÿßŸÑ ŸÉÿßŸÜ ÿßŸÑÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠Ÿãÿß ŸàŸÑŸÖ ÿ™ŸÉÿ™ŸÖŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿÆŸÑÿßŸÑ 20 ÿØŸÇŸäŸÇÿ© ÿå ŸäŸèÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ."
                    }


#==================================== website_charge_amount handler ============================

async def handle_website_charge_amount_From_Bot(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str):
    """Handles user input for charging their website account, prioritizing game winnings, and using bot balance if needed."""

    # ‚úÖ Detect whether the update is a message or callback query
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text
    else:
        return  # Prevent crashes if neither exists

    amount_text = update.message.text.strip()
    processing_sticker_id = "CAACAgIAAxkBAeLe02fdg4hbX96ODk5SRx08-jtV08apAALDPQACzBMpSoUPzZoaigNGNgQ"
    error_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"
    success_sticker_id="CAACAgIAAxkBAeLaJGfddT5-nwAB0D9SFNMeScLbCI3V1QACfz0AAi3JKUp2tyZPFVNcFzYE"
    # ‚úÖ Step 1: Prevent duplicate requests
    if context.user_data.get("processing_transaction"):
        await update.message.reply_sticker(sticker=processing_sticker_id)
        await send_message("‚è≥ ŸÑÿØŸäŸÉ ŸÖÿπÿßŸÖŸÑÿ© ÿ¨ÿßÿ±Ÿäÿ© ÿ®ÿßŸÑŸÅÿπŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ≠ÿ™Ÿâ ÿ™ŸÉÿ™ŸÖŸÑ.")
        return

    # ‚úÖ Step 2: Lock the process
    context.user_data["processing_transaction"] = True

    conn = connect_db()
    cursor = conn.cursor()

    try:
        # ‚úÖ Validate amount
        if not amount_text.isdigit():
            await update.message.reply_sticker(sticker=error_sticker_id)
            await send_message("‚ö†Ô∏è ÿßŸÑŸÖÿ®ŸÑÿ∫ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖŸãÿß ÿµÿ≠Ÿäÿ≠Ÿãÿß!", parse_mode="Markdown")
            return

        amount = int(amount_text)

        if amount <= 0:
            await update.message.reply_sticker(sticker=error_sticker_id)
            await send_message("‚ö†Ô∏è ÿßŸÑŸÖÿ®ŸÑÿ∫ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ 0 SYP", parse_mode="Markdown")
            return

        # ‚úÖ Fetch user's balances
        cursor.execute("SELECT bot_balance, game_balance FROM wallets WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            await send_message("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ!", parse_mode="Markdown")
            return

        bot_balance, game_balance = result

        total_available_balance = bot_balance + game_balance

        if amount > total_available_balance:
            await update.message.reply_sticker(sticker=error_sticker_id)
            await send_message("‚ö†Ô∏è ÿ±ÿµŸäÿØŸÉ ÿ∫Ÿäÿ± ŸÉÿßŸÅŸç ŸÑŸáÿ∞ÿß ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ!", parse_mode="Markdown")
            return

        # ‚úÖ Step 3: Determine how to deduct balance
        game_used = min(amount, game_balance)  # Use game_balance first
        bot_used = amount - game_used  # If more is needed, use bot_balance

        # ‚úÖ Step 4: Deposit to player's website account FIRST
        await update.message.reply_sticker(sticker=processing_sticker_id)
        await send_message("üîÑ ÿ¨ÿßÿ±Ÿç ÿ™ŸÜŸÅŸäÿ∞ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ¥ÿ≠ŸÜ... Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±!", parse_mode="Markdown")

        deposit_result = deposit_to_player(user_id, amount)

        if deposit_result.get("success"):
            # ‚úÖ Step 5: Update balances in the database
            new_game_balance = game_balance - game_used
            new_bot_balance = bot_balance - bot_used

            cursor.execute("UPDATE wallets SET game_balance = %s, bot_balance = %s WHERE user_id = %s", 
                           (new_game_balance, new_bot_balance, user_id))
            conn.commit()

            # ‚úÖ Fetch the user's current website balance
            balance_details = fetch_player_balance(user_id)

            if "error" in balance_details:
                await send_message(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿµŸäÿØ: {balance_details['error']}", parse_mode="Markdown")
                return

            new_website_balance = balance_details["balance"]

            cursor.execute("UPDATE wallets SET website_balance = %s WHERE user_id = %s", 
                           (new_website_balance, user_id))
            conn.commit()
             
            if amount >= 100000:
             cursor.execute("select game_points from wallets where user_id = %s",(user_id,))
             game_points=cursor.fetchone()[0]
             game_points += 10
             cursor.execute("update wallets set game_points = %s where user_id = %s",(game_points,user_id))
             conn.commit()

            success_message = (
                f"‚úÖ ÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ®ŸÜÿ¨ÿßÿ≠ ÿ•ŸÑŸâ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ!\n\n"
                f"üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿ≠ŸàŸÑ: `{amount}` SYP\n"
                f"üé∞ ÿ±ÿµŸäÿØ ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÑÿπÿ®ÿ© ÿ®ÿπÿØ ÿßŸÑÿÆÿµŸÖ: `{new_game_balance}` SYP\n"
                f"ü§ñ ÿ±ÿµŸäÿØŸÉ ŸÅŸä ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿ®ÿπÿØ ÿßŸÑÿÆÿµŸÖ: `{new_bot_balance}` SYP\n"
                f"üåç ÿ±ÿµŸäÿØŸÉ ŸÅŸä ÿßŸÑŸÖŸàŸÇÿπ ÿ®ÿπÿØ ÿßŸÑÿ™ÿπÿ®ÿ¶ÿ©: `{new_website_balance}` SYP"
            )
            await update.message.reply_sticker(sticker=success_sticker_id)
            await send_message(success_message, parse_mode="Markdown")

        else:
            # ‚úÖ Replace deposit failure message with a custom response
            error_message = f"‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ•ŸäÿØÿßÿπ ŸÅŸä ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖŸàŸÇÿπ!\n‚ö†Ô∏è ÿßŸÑÿ≥ÿ®ÿ®: {deposit_result['error']}"
            await send_message(error_message, parse_mode="Markdown")

    except Exception as e:
        await send_message(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ: `{str(e)}`", parse_mode="Markdown")

    finally:
        # ‚úÖ Step 6: Unlock the process so the user can make another request
        context.user_data["processing_transaction"] = False
        cursor.close()
        conn.close()

#==================================== website_withdraw_amount handler ============================


async def handle_website_withdraw_amount_To_Bot(update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str):
    """Handles user input for website withdrawals while preventing duplicate requests."""

    # ‚úÖ Detect whether the update is a message or callback query
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text
    else:
        return  # Prevent crashes if neither exists

    amount_text = update.message.text.strip()
    processing_sticker_id = "CAACAgIAAxkBAeLe02fdg4hbX96ODk5SRx08-jtV08apAALDPQACzBMpSoUPzZoaigNGNgQ"
    error_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"
    success_sticker_id="CAACAgIAAxkBAeLaJGfddT5-nwAB0D9SFNMeScLbCI3V1QACfz0AAi3JKUp2tyZPFVNcFzYE"
    warning_sticker_id ="CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
     

    # ‚úÖ Step 1: Prevent duplicate requests
    if context.user_data.get("processing_transaction"):
        await update.message.reply_sticker(sticker=processing_sticker_id)
        await send_message("‚è≥ ŸÑÿØŸäŸÉ ŸÖÿπÿßŸÖŸÑÿ© ÿ¨ÿßÿ±Ÿäÿ© ÿ®ÿßŸÑŸÅÿπŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ≠ÿ™Ÿâ ÿ™ŸÉÿ™ŸÖŸÑ.", parse_mode="Markdown")
        return

    # ‚úÖ Step 2: Lock the process
    context.user_data["processing_transaction"] = True

    conn = connect_db()
    cursor = conn.cursor()

    try:
        # ‚úÖ Validate amount
        if not amount_text.isdigit():
            await update.message.reply_sticker(sticker=error_sticker_id)
            await send_message("‚ö†Ô∏è ÿßŸÑŸÖÿ®ŸÑÿ∫ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖŸãÿß ÿµÿ≠Ÿäÿ≠Ÿãÿß!", parse_mode="Markdown")
            return

        withdrawal_amount = int(amount_text)

        if withdrawal_amount <= 0:
            await update.message.reply_sticker(sticker=error_sticker_id)
            await send_message("‚ö†Ô∏è ÿßŸÑŸÖÿ®ŸÑÿ∫ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ£ŸÉÿ®ÿ± ŸÖŸÜ 0!", parse_mode="Markdown")
            return

        # ‚úÖ Fetch the user's current website balance
        balance_details = fetch_player_balance(user_id)

        if "error" in balance_details:
            await send_message(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿµŸäÿØ: {balance_details['error']}", parse_mode="Markdown")
            return

        website_balance = balance_details["balance"]

        # ‚úÖ Validate withdrawal amount
        if withdrawal_amount > website_balance:
            keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_sticker(sticker=warning_sticker_id)
            await send_message(
                f"‚ùå ÿ±ÿµŸäÿØŸÉ ÿ∫Ÿäÿ± ŸÉÿßŸÅŸç! \n\n"
                f"üí∞ ÿ±ÿµŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ™ÿßÿ≠: `{website_balance}` {balance_details['currency']}\n"
                f"üìå Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ®ŸÑÿ∫ ÿ£ŸÇŸÑ ÿ£Ÿà ŸÖÿ≥ÿßŸàŸä ŸÑÿ±ÿµŸäÿØŸÉ.",
                parse_mode="Markdown",
                reply_markup=reply_markup
            )
            return

        # ‚úÖ Step 3: Process the withdrawal request
        await update.message.reply_sticker(sticker=processing_sticker_id)
        await send_message("üîÑ ÿ¨ÿßÿ±Ÿç ÿ™ŸÜŸÅŸäÿ∞ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≥ÿ≠ÿ®... Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±!", parse_mode="Markdown")
        withdrawal_status = withdraw_from_website(user_id, withdrawal_amount)
        
        if withdrawal_status.get("success"):
            print("after the withdrawal call ")
            keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            # ‚úÖ Update the database: Deduct from website balance and add to bot wallet
            cursor.execute(
                "UPDATE wallets SET website_balance = website_balance - %s, bot_balance = bot_balance + %s WHERE user_id = %s",
                (withdrawal_amount, withdrawal_amount, user_id),
            )
            conn.commit()
            print("before the success message ")
            # ‚úÖ Notify user about successful withdrawal
            await update.message.reply_sticker(sticker=success_sticker_id)
            await send_message(
                f"‚úÖ ÿ™ŸÖÿ™ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≥ÿ≠ÿ® ÿ®ŸÜÿ¨ÿßÿ≠!\n\n"
                f"üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿ≥ÿ≠Ÿàÿ®: `{withdrawal_amount}` SYP\n"
                f"üí≥ ÿ±ÿµŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ¨ÿØŸäÿØ: `{website_balance - withdrawal_amount}` SYP\n"
                f"ü§ñ ÿ±ÿµŸäÿØŸÉ ŸÅŸä ÿßŸÑÿ®Ÿàÿ™: `{withdrawal_amount}`SYP",
                
                parse_mode="Markdown",
                reply_markup=reply_markup
            )

        else:
            # ‚úÖ Withdrawal failed
            keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data='back')]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_sticker(sticker=error_sticker_id)
            await send_message(
                f"‚ùå ŸÅÿ¥ŸÑÿ™ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≥ÿ≠ÿ®!\n"
                f"üìå ÿßŸÑÿ≥ÿ®ÿ®: {withdrawal_status.get('error', 'ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ')}",
                parse_mode="Markdown",
                reply_markup=reply_markup
            )

    except Exception as e:
        await send_message(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ: `{str(e)}`", parse_mode="Markdown")

    finally:
        # ‚úÖ Step 4: Unlock the process so the user can make another request
        context.user_data["processing_transaction"] = False
        cursor.close()
        conn.close()


#-------------------------------------handle_withdraw_amount_from_bot_to_user-------------------



   
    
#------------------------------------show last 5 transaction handler ----------------------------

async def handle_show_last_transactions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetch and display the last 5 transactions when the user clicks the inline button."""
    
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    conn = connect_db()
    cursor = conn.cursor()
    
    try:
        # ‚úÖ Fetch the last 5 transactions for the user
        cursor.execute("""
            SELECT amount, transaction_type, payment_method, status, timestamp 
            FROM transactions 
            WHERE user_id = %s 
            ORDER BY timestamp DESC 
            LIMIT 5
        """, (user_id,))
        transactions = cursor.fetchall()

        if not transactions:
            
            await query.edit_message_text("üîç ŸÑÿß ŸäŸàÿ¨ÿØ ŸÑÿØŸäŸÉ ÿ£Ÿä ŸÖÿπÿßŸÖŸÑÿßÿ™ ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ.", parse_mode="Markdown")
            return

        # ‚úÖ Format transaction history
        history = "\n\n".join([
            f"üìÖ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ: `{t[4]}`\n"
            f"üîÑ ÿßŸÑŸÜŸàÿπ: `{t[1]}`\n"
            f"üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫: `{t[0]}` SYP\n"
            f"üí≥ ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ: `{t[2] if t[2] else 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØÿ©'}`\n"
            f"üìå ÿßŸÑÿ≠ÿßŸÑÿ©: `{t[3]}`"
            for t in transactions
        ])

        # ‚úÖ Add a "Back to Menu" button
        keyboard = [[InlineKeyboardButton("üîô ÿ±ÿ¨Ÿàÿπ", callback_data="back")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"üìú ÿ¢ÿÆÿ± 5 ŸÖÿπÿßŸÖŸÑÿßÿ™ ŸÑŸÉ:\n\n{history}",
            parse_mode="Markdown",
            reply_markup=reply_markup
        )

    except Exception as e:
        await query.message.reply_text(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ: `{str(e)}`", parse_mode="Markdown")

    finally:
        cursor.close()
        conn.close()

    

#==================================== ÿ¥ÿ≠ŸÜ ÿßŸÑÿ≠ÿ≥ÿßÿ® function =======================================


def deposit_to_player(user_id, amount):
    """Deposits the specified amount to the user's website account before updating the database."""
    
    conn = connect_db()
    cursor = conn.cursor()
    
    try:
        # ‚úÖ Ensure agent session is active
        global agent_session
        if not agent_session and not login_as_agent():
            return {"error": "Agent login failed"}

        # ‚úÖ Fetch player ID from the database
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            return {"error": "Player ID not found in database"}

        player_id = result[0]  # Extract player ID
        currency_code = "NSP"  # Ensure this is the correct currency

        # ‚úÖ Prepare the request payload
        payload = {
            "amount": amount,
            "comment": None,
            "playerId": str(player_id),
            "currencyCode": currency_code,
            "currency": currency_code,
            "moneyStatus": 5
        }

        headers = {
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        }

    except Exception as db_error:
        return {"error": f"Database error: {str(db_error)}"}

    finally:
        cursor.close()
        conn.close()

    # ‚úÖ Send deposit request
    try:
        response = agent_session.post(DEPOSIT_URL, json=payload, headers=headers)
        response.raise_for_status()  # Raises an error if request fails
        data = response.json()

          # ‚úÖ Handle success
        if data.get("status") and isinstance(data.get("result"), dict):
            return {"success": True, "message": "Deposit successful"}

        # ‚úÖ Handle failure (extract error message properly)
        notifications = data.get("notification", [])
        if notifications and isinstance(notifications, list) and len(notifications) > 0:
            error_message = notifications[0].get("content", "Unknown error")
        else:
            error_message = "Unknown error (No notifications provided)"
        
        return {"error": error_message}

    except requests.exceptions.RequestException as e:
        return {"error": f"Request failed: {str(e)}"}


#==================================== withdrawal from the website  functions =======================================

def withdraw_from_website(user_id, amount):
    """Withdraw funds from the website account to the bot wallet."""
    
    conn = connect_db()
    cursor = conn.cursor()
    
    try:
        # ‚úÖ Ensure agent session is active
        global agent_session
        if not agent_session and not login_as_agent():
            return {"error": "Failed to log in as agent"}

        # ‚úÖ Fetch player_id from the database
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()

        if not result:
            return {"error": "User ID not found in accounts table"}

        player_id = result[0]  # Extract player_id

        # ‚úÖ Fetch current website balance
        cursor.execute("SELECT website_balance FROM wallets WHERE user_id = %s", (user_id,))
        balance_result = cursor.fetchone()

        if not balance_result:
            return {"error": "Wallet not found"}
        
        website_balance = balance_result[0]

        # ‚úÖ Validate if user has enough balance
        if amount > website_balance:
            return {"error": "Insufficient balance"}

        # ‚úÖ Prepare withdrawal payload
        payload = {
            "amount": -amount,  # The API requires a negative amount
            "comment": None,
            "playerId": str(player_id),
            "currencyCode": "NSP",
            "currency": "NSP",
            "moneyStatus": 5
        }

        # ‚úÖ Send the withdrawal request
        response = agent_session.post(WITHDRAW_WEBSITE_URL, json=payload)
        response.raise_for_status()  # Raise error if request fails
        data = response.json()

        # ‚úÖ Handle API response properly
        if data.get("status") and isinstance(data.get("result"), dict):
            # ‚úÖ Deduct from website balance and add to bot wallet
            cursor.execute(
                "UPDATE wallets SET website_balance = website_balance - %s, bot_balance = bot_balance + %s WHERE user_id = %s",
                (amount, amount, user_id)
            )

            # ‚úÖ Log transaction
          
            return {"success": True, "message": f"Successfully withdrawn {amount} NSP from website to bot wallet!"}

        else:
            # ‚úÖ Handle failure correctly
            notifications = data.get("notification", [])
            if notifications and isinstance(notifications, list) and len(notifications) > 0:
                error_message = notifications[0].get("content", "Unknown error")
            else:
                error_message = "Unknown error (No notifications provided)"
            
            return {"error": error_message}

    except requests.exceptions.RequestException as e:
        return {"error": f"Request failed: {str(e)}"}

    except Exception as db_error:
        return {"error": f"Database error: {str(db_error)}"}

    finally:
        cursor.close()
        conn.close()  # ‚úÖ Ensure database connection is closed

#-------------------------------- withdrawal_from_bot_to_user function--------------------------------------------
async def process_withdrawal_amount_from_bot_to_user(update: Update, context: ContextTypes.DEFAULT_TYPE, amount: str, method: str):
    """Handles withdrawals for different payment methods dynamically."""
    print("Processing withdrawal request...")
    conn = connect_db()
    cursor = conn.cursor()

    # ‚úÖ Detect whether the update is a message or callback query
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text
    else:
        return  # Prevent crashes if neither exists
    
   
    erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"
    warning_sticker_id ="CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
    what_sticker_id ="CAACAgIAAxkBAeLkf2fdjvmHUYuWm-x2JOFH3xs--fgyAALUMAACmTChSgQ1fTazyf2VNgQ"
    
    # ‚úÖ Convert amount safely
    try:
        amount = int(amount)
    except ValueError:
        await update.message.reply_sticker(sticker=erorr_sticker_id)
        await send_message("‚ö†Ô∏è ÿßŸÑŸÖÿ®ŸÑÿ∫ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖŸãÿß ÿµÿ≠Ÿäÿ≠Ÿãÿß!", parse_mode="Markdown")
        return

    # ‚úÖ Ensure a method was selected
    if not method:
        await send_message("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ≥ÿ≠ÿ®!", parse_mode="Markdown")
        return

    # ‚úÖ Fetch user balance
    cursor.execute("SELECT bot_balance FROM wallets WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    if not result:
        await send_message("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ!")
        return

    bot_balance = int(result[0])

    # ‚úÖ Check if the user has enough balance
    if amount > bot_balance:
        await update.message.reply_sticker(sticker=warning_sticker_id)
        await send_message("‚ö†Ô∏è ÿ±ÿµŸäÿØŸÉ ŸÅŸä ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿ∫Ÿäÿ± ŸÉÿßŸÅŸç ŸÑŸáÿ∞ÿß ÿßŸÑÿ≥ÿ≠ÿ®!")
        return

    # ‚úÖ Handle Payeer (USD to SYP conversion)
    if method == "payeer":
        print("Method is Payeer")

        # ‚úÖ Ensure exchange rate is defined
        global exchange_rate
        if not exchange_rate:
            await send_message("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ≥ÿπÿ± ÿßŸÑÿµÿ±ŸÅÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇŸãÿß.")
            return

        USD_to_SYP = round(amount * exchange_rate)

        if USD_to_SYP > bot_balance:
            await update.message.reply_sticker(sticker=warning_sticker_id)
            await send_message("‚ö†Ô∏è ÿ±ÿµŸäÿØŸÉ ŸÅŸä ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿ∫Ÿäÿ± ŸÉÿßŸÅŸç ŸÑŸáÿ∞ÿß ÿßŸÑÿ≥ÿ≠ÿ®!")
            return

        # ‚úÖ Store the converted amount before continuing
        context.user_data["withdraw_amount"] = USD_to_SYP

        # ‚úÖ Define confirmation keyboard
        keyboard = [
            [InlineKeyboardButton("‚úî ÿ™ÿ£ŸÉŸäÿØ", callback_data=f"confirm_withdraw_{USD_to_SYP}_{method}")],
            [InlineKeyboardButton("‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data="cancel_withdraw")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # ‚úÖ Send confirmation message for Payeer
        withdrawal_message = (
            f"üíµ ÿ≥ÿπÿ± ÿßŸÑÿµÿ±ŸÅ:  Payeer 1 USD = {exchange_rate} SYP\n\n"
            f"‚ö†Ô∏è ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≥ÿ≠ÿ® {USD_to_SYP} SYP ÿπÿ®ÿ± {method.upper()}ÿü\n\n"
            f"üí∞ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿπŸÑŸâ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ≥ÿ≠ÿ®: \n"
            f"üîπ 5Ÿ™ - ÿπŸÑŸâ ŸÉŸÑ ÿπŸÖŸÑŸäÿ© ÿ≥ÿ≠ÿ®\n\n"
            f"‚ö†Ô∏è Ÿäÿ™ŸÖ ÿÆÿµŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿπŸÜÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ∑ŸÑÿ®."
        )
        await update.message.reply_sticker(sticker=what_sticker_id)
        await send_message(withdrawal_message, reply_markup=reply_markup, parse_mode="Markdown")

    else:
        # ‚úÖ Store the withdrawal amount before confirmation
        context.user_data["withdraw_amount"] = amount

        # ‚úÖ Define confirmation keyboard
        keyboard = [
            [InlineKeyboardButton("‚úî ÿ™ÿ£ŸÉŸäÿØ", callback_data=f"confirm_withdraw_{amount}_{method}")],
            [InlineKeyboardButton("‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data="cancel_withdraw")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # ‚úÖ Send confirmation message for normal withdrawals (Bemo, Syriatel, etc.)
        withdrawal_message = (
            f"‚ö†Ô∏è ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≥ÿ≠ÿ® {amount} SYP ÿπÿ®ÿ± {method.upper()}ÿü\n\n"
            f"üí∞ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿπŸÑŸâ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ≥ÿ≠ÿ®: \n"
            f"üîπ 5Ÿ™ - ÿπŸÑŸâ ŸÉŸÑ ÿπŸÖŸÑŸäÿ© ÿ≥ÿ≠ÿ®\n\n"
            f"‚ö†Ô∏è Ÿäÿ™ŸÖ ÿÆÿµŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿπŸÜÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ∑ŸÑÿ®."
        )
        await update.message.reply_sticker(sticker=what_sticker_id)
        await send_message(withdrawal_message, reply_markup=reply_markup, parse_mode="Markdown")

    # ‚úÖ Set state for confirmation
    context.user_data["state"] = "confirm_withdraw"

    # ‚úÖ Close database connection
    cursor.close()
    conn.close()




async def finalize_withdrawal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Calculates fees, updates transaction status, and confirms withdrawal request."""
    conn = connect_db()
    cursor = conn.cursor(dictionary=True)  # Using dictionary=True to fetch data as dict
    query = update.callback_query
    
    if update.message:
        user_id = update.message.from_user.id
        send_message = update.message.reply_text  # ‚úÖ Use update.message
    elif update.callback_query:
        user_id = update.callback_query.from_user.id
        send_message = update.callback_query.message.reply_text  # ‚úÖ Use update.callback_query.message
    else:
        return 
    success_sticker_id="CAACAgIAAxkBAeLfjWfdhmXMrgLfaZJoEAWhTenCC6DrAALnNQACtoxBS2JmFwWrYLwGNgQ"
    erorr_sticker_id ="CAACAgIAAxkBAeLfqGfdhv5zCSIhUgJGjM6LbmkaIB9wAAJxOwACtUNZSjpcwC49bZ4dNgQ"

    # Retrieve stored withdrawal details
    amount = context.user_data.get("withdraw_amount")
    method = context.user_data.get("withdraw_method")
    account_number = context.user_data.get("account_number")

    if not amount or not method or not account_number:
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£! ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿØÿÆÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠.", parse_mode="Markdown")
        return

    # Convert amount to integer if it's stored as a string
    try:
        amount = int(amount)
    except ValueError:
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message("‚ùå ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠!", parse_mode="Markdown")
        return

    # Calculate withdrawal fees
    
    fee_percentage = 0.05

    fee = round(amount * fee_percentage)
    final_amount = amount - fee

    # Prevent final_amount from being negative
    if final_amount < 0:
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message("‚ùå ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÜŸáÿßÿ¶Ÿä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿå Ÿäÿ±ÿ¨Ÿâ ŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ!", parse_mode="Markdown")
        return

    try:
        # Deduct balance from bot wallet
        cursor.execute("SELECT bot_balance FROM wallets WHERE user_id = %s", (user_id,))
        result = cursor.fetchone()
        bot_balance = result["bot_balance"] if result else 0

        if bot_balance < final_amount:
            await update.message.reply_sticker(sticker=success_sticker_id)
            await send_message("‚ùå ÿ±ÿµŸäÿØŸÉ ÿ∫Ÿäÿ± ŸÉÿßŸÅŸç ŸÑŸÑÿ≥ÿ≠ÿ®!", parse_mode="Markdown")
            return

        cursor.execute("UPDATE wallets SET bot_balance = bot_balance - %s WHERE user_id = %s", (final_amount, user_id))
        # Fetch player_id correctly
        cursor.execute("SELECT player_id FROM accounts WHERE user_id = %s", (user_id,))
        player_id_result = cursor.fetchone()
        player_id = player_id_result["player_id"] if player_id_result else None

# Ensure player_id exists
        if player_id is None:
            await send_message("‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ Player ID ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿ≠ÿ≥ÿßÿ®ŸÉ!", parse_mode="Markdown")
            return

# Insert transaction details (with player_id properly extracted)
        cursor.execute("INSERT INTO transactions (user_id, amount, player_id, transaction_type, status, payment_method, account_number, fee, final_amount) "
            "VALUES (%s, %s, %s, 'withdrawal', 'approved', %s, %s, %s, %s)",
         (user_id, amount, player_id, method, account_number, fee, final_amount)
)


        conn.commit()

        # Notify the user
        await update.message.reply_sticker(sticker=success_sticker_id)
        await send_message(
            f"‚úÖ ÿ∑ŸÑÿ® ÿßŸÑÿ≥ÿ≠ÿ® ŸÇŸäÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©! üè¶\n\n"
            f"üí≥ ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ≥ÿ≠ÿ®: `{method.upper()}`\n"
            f"üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®: `{amount}` SYP\n"
            f"üßæ ÿßŸÑÿ±ÿ≥ŸàŸÖ: `{fee}` SYP\n"
            f"üìâ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÜŸáÿßÿ¶Ÿä: `{final_amount}` SYP\n"
            f"üè¶ ÿ±ŸÇŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ®: `{account_number}`\n\n"
            f"‚åõ ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ∑ŸÑÿ® ÿÆŸÑÿßŸÑ 24 ÿ≥ÿßÿπÿ©.",
            parse_mode="Markdown"
        )

    except mysql.connector.Error as err:
        await send_message(f"‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {err}", parse_mode="Markdown")
        conn.rollback()  # Rollback on failure

    finally:
        cursor.close()
        conn.close()


async def start_slot_machine(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """Start the slot machine game and send a sticker animation."""
     user_id = update.callback_query.from_user.id
     chat_id = update.callback_query.message.chat_id  # Get chat ID
 
     
 
     # ‚úÖ Connect to the database
     conn = connect_db()
     cursor = conn.cursor()
     
     cursor.execute("update wallets set game_points = game_points - 1 where user_id = %s", (user_id,))
     conn.commit()
     
     cursor.execute("select game_points from wallets where user_id = %s",(user_id,))
     game_points = cursor.fetchone()[0]
     print (f"{game_points}")
     if game_points == 0 :
         slot_sticker_id = "CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
         await context.bot.send_sticker(chat_id=chat_id, sticker=slot_sticker_id)# if the game status = 0 that's mean that the player reached his limits 
         await update.callback_query.message.reply_text(
             "‚ö†Ô∏è ŸÖÿß ŸÖÿπŸÉ ŸÜŸÇÿßÿ∑ ŸÉŸÅÿßŸäÿ© ŸÑÿ™ŸÑÿπÿ® üéÆüíî\n\n"
             "ŸÑÿßÿ≤ŸÖ ÿ™ÿ¥ÿ≠ŸÜ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÄ WayXbet ŸÖÿ¥ÿßŸÜ ÿ™ÿ¨ŸÖÿπ ŸÜŸÇÿßÿ∑ ‚ú®\n\n"
             "üîπ ŸÉŸÑ ÿπŸÖŸÑŸäÿ© ÿ¥ÿ≠ŸÜ ŸÅŸàŸÇ 100,000 ŸÑ.ÿ≥ ÿ®ÿ™ÿπÿ∑ŸäŸÉ 10 ŸÜŸÇÿßÿ∑ üéÅ\n\n"
             "üîπ ŸÉŸÑ ŸÜŸÇÿ∑ÿ© ÿ®ÿ™ÿÆŸÑŸäŸÉ ÿ™ÿπŸÖŸÑ ÿ≥ÿ®ŸäŸÜ ÿ®ÿßŸÑŸÑÿπÿ®ÿ© üé∞ \n\n"
             "ŸäŸÑÿß ÿßÿ¥ÿ≠ŸÜ Ÿàÿ¨ŸÖŸëÿπ ŸÜŸÇÿßÿ∑ŸÉ! üí™üî•",
             parse_mode="Markdown"
         )
         conn.close()
         
     
     
     
     cursor.execute("SELECT SUM(total_game_balance) FROM wallets")
     updated_total_game_balance = cursor.fetchone()[0] or 0
     print(f"{updated_total_game_balance}")
     if updated_total_game_balance >= 1000000:
         slot_sticker_id = "CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
         await context.bot.send_sticker(chat_id=chat_id, sticker=slot_sticker_id)
         message = "\n\nüö´ ÿßŸÑŸÑÿπÿ®ÿ© ŸÖŸÇŸÅŸÑÿ© ÿßŸÑÿ¢ŸÜ! ŸàÿµŸÑÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨Ÿàÿßÿ¶ÿ≤ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ (1,000,000 SYP)."
         # ‚úÖ Send result message
         keyboard = [[InlineKeyboardButton("üîÑ ŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ", callback_data="slot_machine")]]
         reply_markup = InlineKeyboardMarkup(keyboard)
 
         await update.callback_query.message.reply_text(message, reply_markup=reply_markup, parse_mode="Markdown")
         conn.close()
     
     
     
         
 
     # ‚úÖ Check user's game balance
     cursor.execute("SELECT game_balance FROM wallets WHERE user_id = %s", (user_id,))
     game_balance = cursor.fetchone()
 
     if not game_balance:
         game_balance = (0,)  # Default to 0 if user has no record
 
     # ‚úÖ Check if the user already hit their 50,000 SYP limit
     cursor.execute("SELECT game_status from wallets where user_id =%s",(user_id,))
     game_status = cursor.fetchone()
     if game_balance[0] >= 50000 or game_status[0] == 0:
         slot_sticker_id = "CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
         await context.bot.send_sticker(chat_id=chat_id, sticker=slot_sticker_id)# if the game status = 0 that's mean that the player reached his limits 
         await update.callback_query.message.reply_text(
             "‚ö†Ô∏è ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑÿ£ÿ±ÿ®ÿßÿ≠ŸÉ (50,000 SYP).\n\n"
             "üö´ ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿßŸÑŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
             parse_mode="Markdown"
         )
         cursor.execute("UPDATE wallets set game_status = %s where user_id = %s" ,(0,user_id))
         conn.commit()
         conn.close()
         return
 
     # ‚úÖ Generate slot machine result
     symbols = ["üçí", "üçã", "üçâ"]
     result = [random.choice(symbols) for _ in range(3)]
 
     # ‚úÖ Check if the player won (all symbols match)
     win_amount = 25000 if result[0] == result[1] == result[2] else 0
 
     if win_amount > 0:
         
          # ‚úÖ Add winnings to user's game balance
         cursor.execute("UPDATE wallets SET game_balance = game_balance + %s WHERE user_id = %s", (win_amount, user_id))
    
         # ‚úÖ Update the total game balance correctly
         cursor.execute("UPDATE wallets SET total_game_balance = total_game_balance + %s WHERE user_id = %s", (win_amount, user_id))
    
         conn.commit()
         # ‚úÖ Send Slot Machine Sticker (Replace with your own `file_id`)
         slot_sticker_id = "CAACAgIAAxkBAeLaJGfddT5-nwAB0D9SFNMeScLbCI3V1QACfz0AAi3JKUp2tyZPFVNcFzYE"
         await context.bot.send_sticker(chat_id=chat_id, sticker=slot_sticker_id)
 
     # ‚úÖ Get updated total balance after the spin
     
 
     
 
     # ‚úÖ Generate game message
     message = f"üé∞ ŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑÿ≥ÿ≠ÿ®: \n\n {result[0]} | {result[1]} | {result[2]} |\n\n"
 
     if win_amount > 0:
         message += (
             f"üéâ ŸÖÿ®ÿ±ŸàŸÉ! ÿ±ÿ®ÿ≠ÿ™ `{win_amount}` ŸÑ.ÿ≥ üéâ\n"
             f"üí∞ ÿ±ÿµŸäÿØŸÉ ŸÅŸä ÿßŸÑŸÑÿπÿ®ÿ©: `{game_balance[0] + win_amount}` ŸÑ.ÿ≥\n"
             f"üö´ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿ≥ÿ≠ÿ® ÿ±ÿµŸäÿØ ÿßŸÑŸÑÿπÿ®ÿ© \n"
             "üîÑ ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠ ŸÑÿ¥ÿ≠ŸÜ ÿ≠ÿ≥ÿßÿ®ŸÉ ŸÅŸä WayXbet!"
         )
     else:
         message += "üòî ŸÑŸÑÿ£ÿ≥ŸÅ ŸÑŸÖ ÿ™ŸÅÿ≤ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ±ÿ©.\nüîÑ ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ!"
 
     # ‚úÖ Check if the total game balance exceeded the global limit
     if updated_total_game_balance >= 1000000:
         cursor.execute("UPDATE game_settings SET game_locked = 1")
         conn.commit()
         conn.close()
         slot_sticker_id = "CAACAgIAAxkBAeLea2fdghlNXrLzSIKqJ_kW8t43fAE1AALzQQACb7NoSV-j4NDXxKN2NgQ"
         await context.bot.send_sticker(chat_id=chat_id, sticker=slot_sticker_id)
         message += "\n\nüö´ ÿßŸÑŸÑÿπÿ®ÿ© ŸÖŸÇŸÅŸÑÿ© ÿßŸÑÿ¢ŸÜ! ŸàÿµŸÑÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨Ÿàÿßÿ¶ÿ≤ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ (1,000,000 SYP)."
 
     # ‚úÖ Send result message
     keyboard = [[InlineKeyboardButton("üîÑ ŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ", callback_data="slot_machine")]]
     reply_markup = InlineKeyboardMarkup(keyboard)
 
     await update.callback_query.message.reply_text(message, reply_markup=reply_markup, parse_mode="Markdown")

# ‚úÖ Register handlers
telegram_app.add_handler(CommandHandler("start", start))
telegram_app.add_handler(CommandHandler("help", help_command))
telegram_app.add_handler(CallbackQueryHandler(button))
telegram_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_user_input))

if __name__ == "__main__":
    
    login_as_agent()
    uvicorn.run(app, host="0.0.0.0", port=8000)
